<!doctype html>
<!--
Copyright (C) 2019 by Rufas Wan

This file is part of Web2D Games.
    <https://github.com/rufaswan/Web2D_Games>

Web2D Games is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Web2D Games is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Web2D Games.  If not, see <http://www.gnu.org/licenses/>.
-->
<html><head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<title>Quad Player - Mobile</title>
<style>body {
	background-color : #404040;
}
body, a, a:hover, a:visited {
	color       : #c0c0c0;
	font-family : sans-serif;
}

button {
	background-color : rgba(255 , 255 , 255 , 0.5);
	white-space      : nowrap;
	text-transform   : uppercase;
	margin           : 18px;
	min-width        : 42px;
	min-height       : 42px;
	padding          : 0.5em;
	border           : 0;
}
button.btn_on {
	background-color : rgba(0 , 255 , 0 , 0.5);
	color            : #000;
}

button.btn_off {
	background-color : rgba(255 , 0 , 0 , 0.5);
	color            : #fff;
}

textarea {
	display          : block;
	width            : 95%;
	height           : 25em;
	margin           : 0 auto 0;
	background-color : #fff;
	color            : #000;
	resize           : none;
}

h1, h2, h3, h4, h5, h6 {
	text-transform : uppercase;
	border-bottom  : 1px #808080 solid;
}

ul {
	list-style-type : none;
}

.hidden {
	display : none;
}

#viewer {
	position : fixed;
	left     : 0;
	top      : 0;
	width    : 100vw;
	height   : 100vh;
	overflow : auto;
	display  : none;
}

#viewer #canvas,
#viewer img {
	position : absolute;
	top      : 0;
	left     : 0;
	width    : 100%;
	height   : 100%;
}

#viewer_top_nav,
#debugger_top_nav {
	position : fixed;
	top      : 0;
	left     : 0;
	width    : 100vw;
	display  : block;
}
#debugger_top_nav {
	background-color : #404040;
	border-bottom    : 2px #c0c0c0 solid;
}
#viewer_top_nav p,
#debugger_top_nav p {
	display         : flex;
	flex-direction  : row;
	flex-wrap       : nowrap;
	justify-content : space-between;
	align-items     : center;
	margin          : 0;
	padding         : 0;
}

#viewer_bottom_nav {
	position : fixed;
	bottom   : 0;
	left     : 0;
	width    : 100vw;
	display  : block;
}
#viewer_bottom_nav p {
	display         : flex;
	flex-direction  : row;
	flex-wrap       : nowrap;
	justify-content : space-between;
	align-items     : center;
	margin          : 0;
	padding         : 0;
}

#export_div {
	position         : fixed;
	bottom           : 0;
	background-color : #404040;
	display          : none;
	text-align       : center;
	border-top       : 2px #c0c0c0 solid;
	padding-top      : 1em;
	width            : 100vw;
}

#export_div button {
	margin : 1em;
}

#quad_data p {
	line-height     : 42px;
	display         : flex;
	flex-direction  : row;
	flex-wrap       : nowrap;
	justify-content : space-around;
	align-items     : center;
}

#quad_data ul {
	padding : 0;
}
#quad_data ul ul {
	padding-left : 42px;
}

#quad_data .liexpand,
#quad_data .liexport {
	background-color : rgba(255 , 255 , 255 , 0.5);
	color            : #000;
	white-space      : nowrap;
	text-transform   : uppercase;
	text-align       : center;
	min-height       : 42px;
	padding          : 0.5em;
}

#quad_data .liname {
	flex-grow : 2;
	border    : 1px #c0c0c0 solid;
	padding   : 0 0.5em;
}
#quad_data .current {
	background-color : #c0c0c0;
	color            : #404040;
}

#quad_data_tags {
	padding-left : 42px;
}
#quad_data_tags p {
	display      : block;
	padding-left : 42px;
}
</style>
<script>'use strict';

function get_html_id(){
	var html = {};
	var eles = document.querySelectorAll('*[id]');
	for ( var i=0; i < eles.length; i++ ) {
		var id  = eles[i].id;
		html[id] = eles[i];
	}
	return html;
}

function display_viewer( html, toggle ){
	if ( toggle ){
		html.viewer.style.display   = 'block';
		//html.debugger.style.display = 'none';
	}
	else {
		html.viewer.style.display   = 'none';
		//html.debugger.style.display = 'block';
	}
	html.export_div.style.display = 'none';
}

function btn_toggle( elem, turn ){
	var css = elem.classList;
	if ( turn > 0 ){
		css.remove('btn_off');
		css.add('btn_on');
		return;
	}
	if ( turn < 0 ){
		css.remove('btn_on');
		css.add('btn_off');
		return;
	}
	css.remove('btn_on');
	css.remove('btn_off');
}

function btn_prev_next( qdata, adj ){
	adj = adj | 0;
	if ( ! qdata || adj === 0 )
		return;
	if ( ['keyframe','hitbox','slot'].indexOf(qdata.attach.type) !== -1 )
		qdata.attach.id += adj;
	else
		qdata.anim_fps  += adj;
}

function qdata_filetable( qdata, files ){
	files.innerHTML = '';
	if ( qdata.name )
		files.innerHTML += '<li>[QUAD] ' + qdata.name + '</li>';
	for ( var i=0; i < qdata.image.length; i++ ){
		if ( ! qdata.image[i] || ! qdata.image[i].name )
			continue;
		var img = qdata.image[i];
		files.innerHTML += '<li>[IMAGE][' + i + '] ' + img.name + ' (' + JSON.stringify(img.pos) + ')</li>';
	}
}

function qdata_tagtable( tag ){
	if ( ! tag )
		return '';
	function wikilink( tagkey, tagval ){
		if ( tagkey.toLowerCase() === 'comment' || tagval === '-' )
			return tagval;
		var href = tagval.replace(/ /g, '_');
		return '<a href="https://en.m.wikipedia.org/wiki/' + href + '" target="_blank">' + tagval + '</a>';
	}

	var buffer = '<h2>tag</h2>';
	buffer += '<div id="quad_data_tags">';

	var keys = Object.keys(tag);
	keys.forEach(function(k){
		var t = {};
		t.l = k;
		if ( Array.isArray(tag[k]) ){
			t.v = [];
			tag[k].forEach(function(tv){
				t.v.push( wikilink( k, tv ) );
			});
			t.r = t.v.join(' , ');
		}
		else {
			t.r = wikilink( k, tag[k] );
		}

		buffer += '<h3>' + t.l + '</h3>';
		buffer += '<p>' + t.r + '</p>';
	});

	buffer += '</div>';
	return buffer;
}

function qdata_attach( qdata, type, id ){
	qdata.attach.type = type;
	qdata.attach.id   = id;
	qdata.anim_fps    = 0;
}

function quad_mainlist( quad ){
	var type = ['skeleton','animation','slot','keyframe','hitbox'];
	for ( var i=0; i < type.length; i++ ){
		var tv = type[i];
		if ( quad[tv].length < 1 )
			continue;
		return tv;
	}
	return -1;
}

function qdata_listing( qdata, type, id ){
	var qchild = QUAD.export.list_attach(qdata, type, id);
	var qtype  = qdata.quad[type][id];

	var qname  = qtype.name || type + ' ' + id;
	if ( QUAD.export.is_loop_attach(qdata, type, id) )
		qname += ' <strong>[LOOP]</strong>';
	if ( QUAD.export.is_mix_attach(qdata, type, id) )
		qname += ' <strong>[MIX]</strong>';

	var html = '<li data-type="' + type + '" data-id="' + id + '"><p>';
	if ( qchild.length > 0 )
		html += '<span class="liexpand" onclick="button_expand(this);">+</span>';

	html += '<span class="liname" onclick="button_select(this);">' + qname + '</span>';

	if ( ['skeleton','animation'].indexOf(type) !== -1 )
		html += '<span class="liexport" onclick="button_export(this);">export</span>';
	html += '</p>';

	if ( qchild.length > 0 ){
		html += '<ul style="display:none;">';
		qchild.forEach(function(cv,ck){
			cv = cv.split(',');
			html += qdata_listing(qdata, cv[0], cv[1]);
		});
		html += '</ul>';
	}

	html += '</li>';
	return html;
}
//////////////////////////////
// TODO : remove all global var

function button_select( elem ){
	if ( SELECTED )
		SELECTED.classList.remove('current');

	SELECTED = elem;
	SELECTED.classList.add('current');

	var par2 = elem.parentElement.parentElement;
	var type = par2.getAttribute('data-type');
	var id   = par2.getAttribute('data-id') | 0;

	qdata_attach(QuadList[0], type, id);
	display_viewer(HTML, true);
}

function button_expand( elem ){
	var par2  = elem.parentElement.parentElement;
	var ulist = par2.getElementsByTagName('ul');
	if ( ulist.length < 1 )
		return;

	var dis = ulist[0].style.display;
	if ( dis === 'block' )
		ulist[0].style.display = 'none';
	else
		ulist[0].style.display = 'block';
}

function button_export( elem ){
	var par2 = elem.parentElement.parentElement;
	var type = par2.getAttribute('data-type');
	var id   = par2.getAttribute('data-id') | 0;

	var div = HTML.export_div;
	div.setAttribute('data-type', type);
	div.setAttribute('data-id'  , id);
	div.style.display = 'block';

	HTML.export_name.innerHTML = type + ' , ' + id;

	var qdata = QuadList[0];
	var time  = QUAD.export.time_attach(qdata, type, id);
	var range = HTML.export_range;
	range.setAttribute('max', time - 1); // index 0
	range.value = 0;
	HTML.export_start.innerHTML = 0;
}

function button_export_type( elem ){
	var par2 = elem.parentElement.parentElement;
	var type = par2.getAttribute('data-type');
	var id   = par2.getAttribute('data-id') | 0;
	var fmt  = elem.innerHTML.toLowerCase();

	var time = HTML.export_start.innerHTML | 0;
	var zoom = 1.0 * HTML.export_zoom.innerHTML;
	QUAD.export.export(fmt, QuadList[0], HTML.canvas, type, id, time, zoom);
}



</script>
<script>'use strict';

var QUAD = {};

(function($){

	function QuadGL(Q){
	var $ = this; // public
	var __ = {};  // private

	//////////////////////////////

	__.GL = '';
	__.SHADER = {};
	__.MAX_TEX_SIZE = -1;

	$.init = function( dom ){
		var opt = {
			alpha                 : true,
			antialias             : true,
			depth                 : true,
			premultipliedAlpha    : false,
			preserveDrawingBuffer : true,
			stencil               : false,
		};
		__.GL = dom.getContext('webgl', opt);
		if ( ! __.GL )
			return Q.func.error('WebGL context failed');
		var form = __.GL.getShaderPrecisionFormat(__.GL.FRAGMENT_SHADER, __.GL.HIGH_FLOAT);
		if ( ! form )
			return Q.func.error('Fragment Shader has no highp support');

		var maxsz = $.detect_max_texsize();
		if ( maxsz < 1 )
			return Q.func.error('MAX_TEXTURE_SIZE < 1', maxsz);
		__.MAX_TEX_SIZE = maxsz | 0;

		var vert_src, frag_src;
		Q.func.log('WebGL + highp init OK',
			['precision',form.precision],
			['MAX_TEXTURE_SIZE',__.MAX_TEX_SIZE]
		);

		//////////////////////////////

		vert_src = `
			attribute  highp  vec2  a_xy;
			uniform    highp  vec2  u_pxsize;

			highp  vec2  XY;
			void main(void){
				XY = a_xy * u_pxsize;
				gl_Position = vec4(XY.x, XY.y, 1.0 , 1.0);
			}
		`;
		frag_src = `
			uniform  highp  vec4  u_color;

			void main(void){
				gl_FragColor = u_color;
			}
		`;
		__.SHADER.lines = __.create_shader('draw lines', vert_src, frag_src);

		//////////////////////////////

		vert_src = `
			attribute  highp  vec4   a_fog;
			attribute  highp  vec3   a_xyz;
			attribute  highp  vec2   a_uv;
			attribute  lowp   float  a_z;
			uniform    highp  vec2   u_pxsize[2];
			varying    highp  vec4   v_fog;
			varying    highp  vec2   v_uv;
			varying    highp  float  v_z;

			highp  vec4   FOG;
			highp  vec2   XY;
			highp  vec2   UV;
			highp  float  z;
			void main(void){
				z = 1.0 / a_xyz.z;
				FOG = a_fog    * z;
				XY  = a_xyz.xy * z * u_pxsize[0];
				UV  = a_uv     * z;

				v_fog = FOG;
				v_uv  = UV;
				v_z   = z;
				gl_Position = vec4(XY.x, XY.y, a_z, 1.0);
			}
		`;
		frag_src = `
			uniform  sampler2D  u_tex;
			uniform  highp  vec2   u_pxsize[2];
			varying  highp  vec4   v_fog;
			varying  highp  vec2   v_uv;
			varying  highp  float  v_z;

			highp  vec4   FOG;
			highp  vec2   UV;
			highp  float  z;
			void main(void){
				z   = 1.0 / v_z;
				FOG = v_fog * z;
				UV  = v_uv  * z * u_pxsize[1];
				gl_FragColor = texture2D(u_tex, UV) * FOG;
			}
		`;
		__.SHADER.keyframe = __.create_shader('draw keyframe', vert_src, frag_src);

		//////////////////////////////

		vert_src = `
			attribute  highp  vec2   a_xy;
			attribute  highp  vec2   a_uv;
			uniform    highp  vec2   u_pxsize[2];
			varying    highp  vec2   v_uv;

			highp  vec2   XY;
			void main(void){
				v_uv = a_uv;

				// convert 0.0 to 1.0 => -1.0 to +1.0
				XY = (a_xy * u_pxsize[0] * 2.0) - 1.0;
				gl_Position = vec4(XY.x, XY.y, 1.0, 1.0);
			}
		`;
		frag_src = `
			uniform  sampler2D  u_tex;
			uniform  highp  vec2   u_pxsize[2];
			varying  highp  vec2   v_uv;

			highp  vec2   UV;
			void main(void){
				UV = v_uv * u_pxsize[1];
				gl_FragColor = texture2D(u_tex, UV);
			}
		`;
		__.SHADER.vram = __.create_shader('draw vram', vert_src, frag_src);

		//////////////////////////////

		return true;
	}

	__.create_shader = function( name, vert_src, frag_src ){
		var vert_shader = __.GL.createShader(__.GL.VERTEX_SHADER);
		__.GL.shaderSource (vert_shader, vert_src);
		__.GL.compileShader(vert_shader);
		var t = __.GL.getShaderParameter(vert_shader, __.GL.COMPILE_STATUS);
		if ( ! t )
			return Q.func.error( __.GL.getShaderInfoLog(vert_shader) );

		var frag_shader = __.GL.createShader(__.GL.FRAGMENT_SHADER);
		__.GL.shaderSource (frag_shader, frag_src);
		__.GL.compileShader(frag_shader);
		var t = __.GL.getShaderParameter(frag_shader, __.GL.COMPILE_STATUS);
		if ( ! t )
			return Q.func.error( __.GL.getShaderInfoLog(frag_shader) );

		var prog = __.GL.createProgram();
		__.GL.attachShader(prog, vert_shader);
		__.GL.attachShader(prog, frag_shader);
		__.GL.linkProgram (prog);
		var t = __.GL.getProgramParameter(prog, __.GL.LINK_STATUS);
		if ( ! t )
			return Q.func.error( __.GL.getProgramInfoLog(prog) );

		Q.func.log('shader init', name);
		return prog;
	}

	//////////////////////////////

	$.draw_line = function( quads, color ){
		__.GL.useProgram( __.SHADER.lines );
		var loc = __.shader_loc(__.SHADER.lines, 'a_xy', 'u_pxsize', 'u_color');
		var view = [ __.GL.drawingBufferWidth * 0.5 , __.GL.drawingBufferHeight * 0.5 ];

		__.GL.lineWidth(2);
		var pxsz = [ 1.0/view[0] , -1.0/view[1] ];

		__.set_vertex_attrib(loc.a_xy, quads, 2);
		__.GL.uniform4fv    (loc.u_color , color);
		__.GL.uniform2fv    (loc.u_pxsize, pxsz);
		__.GL.viewport(0, 0, view[0]*2, view[1]*2);

		var idxlen = quads.length / 2;  // number of x,y
		__.indice_line(idxlen);
	}

	$.draw_keyframe = function( dst, src, fog, z, image ){
		__.GL.useProgram( __.SHADER.keyframe );
		var loc = __.shader_loc(__.SHADER.keyframe, 'a_fog', 'a_xyz', 'a_uv', 'a_z', 'u_pxsize', 'u_tex');
		var view = [ __.GL.drawingBufferWidth * 0.5 , __.GL.drawingBufferHeight * 0.5 ];

		var pxsz = [ 1.0/view[0] , -1.0/view[1] , 1.0/image.w , 1.0/image.h ];
		__.GL.activeTexture(__.GL.TEXTURE0);
		__.GL.bindTexture  (__.GL.TEXTURE_2D, image.tex);

		__.set_vertex_attrib(loc.a_xyz, dst, 3);
		__.set_vertex_attrib(loc.a_uv , src, 2);
		__.set_vertex_attrib(loc.a_fog, fog, 4);
		__.set_vertex_attrib(loc.a_z  , z  , 1);
		__.GL.uniform2fv    (loc.u_pxsize, pxsz);
		__.GL.uniform1i     (loc.u_tex   , 0   );
		__.GL.viewport(0, 0, view[0]*2, view[1]*2);

		var dstlen = dst.length / 3; // number of x,y
		__.indice_quad(dstlen);
	}

	$.draw_vram = function( vram, tex, rect ){
		__.GL.useProgram( __.SHADER.vram );
		var loc = __.shader_loc(__.SHADER.vram, 'a_xy', 'a_uv', 'u_pxsize', 'u_tex');
		var view = [ vram.w * 0.5 , vram.h * 0.5 ];
		var sw = rect[2] - rect[0];
		var sh = rect[3] - rect[1];

		// to be used with canvas - DO NOT flipy !
		var pxsz = [ 1.0/vram.w , 1.0/vram.h , 1.0/sw , 1.0/sh ];
		__.GL.activeTexture(__.GL.TEXTURE0);
		__.GL.bindTexture  (__.GL.TEXTURE_2D, tex);

		var dst = [
			rect[0] , rect[1] ,
			rect[2] , rect[1] ,
			rect[2] , rect[3] ,
			rect[0] , rect[3] ,
		];
		var src = [0,0 , sw,0 , sw,sh , 0,sh];
		__.set_vertex_attrib(loc.a_xy, dst, 2);
		__.set_vertex_attrib(loc.a_uv, src, 2);
		__.GL.uniform2fv    (loc.u_pxsize, pxsz);
		__.GL.uniform1i     (loc.u_tex   , 0   );
		__.GL.viewport(0, 0, vram.w, vram.h);

		$.enable_framebuffer(vram.tex);
		__.indice_quad(4);
		$.enable_framebuffer(0);
	}

	__.indice_line = function( len ){
		var idx = [];
		for ( var i=0; i < len; i += 4 )
			idx.push(i+0,i+1 , i+1,i+2 , i+2,i+3 , i+3,i+0);

		var buf = __.GL.createBuffer();
		__.GL.bindBuffer(__.GL.ELEMENT_ARRAY_BUFFER, buf);
		__.GL.bufferData(__.GL.ELEMENT_ARRAY_BUFFER, new Uint16Array(idx), __.GL.STATIC_DRAW);

		// 1 quad = 4 x,y   = 8 numbers
		//        = 4 lines = 8 points / indices
		__.GL.drawElements(__.GL.LINES, len/4*8, __.GL.UNSIGNED_SHORT, 0);
	}

	__.indice_quad = function( len ){
		var idx = [];
		for ( var i=0; i < len; i += 4 )
			idx.push(i+0,i+1,i+2 , i+0,i+2,i+3);

		var buf = __.GL.createBuffer();
		__.GL.bindBuffer(__.GL.ELEMENT_ARRAY_BUFFER, buf);
		__.GL.bufferData(__.GL.ELEMENT_ARRAY_BUFFER, new Uint16Array(idx), __.GL.STATIC_DRAW);

		// 1 quad = 4 x,y       =  8 numbers
		//        = 4 x,y,z     = 12 numbers
		//        = 2 triangles =  6 points / indices
		__.GL.drawElements(__.GL.TRIANGLES, len/4*6, __.GL.UNSIGNED_SHORT, 0);
	}

	__.shader_loc = function(){
		var shader = arguments[0];
		var loc    = {};
		for ( var i=1; i < arguments.length; i++ )
		{
			var v = arguments[i];
			switch ( v.charAt(0) ){
			case 'a':  loc[v] = __.GL.getAttribLocation (shader, v); break;
			case 'u':  loc[v] = __.GL.getUniformLocation(shader, v); break;
			}
		} // for ( var i=1; i < arguments.length; i++ )
		return loc;
	}

	__.set_vertex_attrib = function( loc, data, v ){
		var buf = __.GL.createBuffer();
		__.GL.bindBuffer(__.GL.ARRAY_BUFFER, buf);
		__.GL.bufferData(__.GL.ARRAY_BUFFER, new Float32Array(data), __.GL.STATIC_DRAW);
		__.GL.enableVertexAttribArray(loc);
		__.GL.vertexAttribPointer(loc, v, __.GL.FLOAT, false, 0, 0);
	}

	//////////////////////////////

	$.create_texture = function(){
		var tex = __.GL.createTexture();
		__.GL.bindTexture  (__.GL.TEXTURE_2D, tex);
		__.GL.texParameteri(__.GL.TEXTURE_2D, __.GL.TEXTURE_WRAP_S    , __.GL.CLAMP_TO_EDGE);
		__.GL.texParameteri(__.GL.TEXTURE_2D, __.GL.TEXTURE_WRAP_T    , __.GL.CLAMP_TO_EDGE);
		__.GL.texParameteri(__.GL.TEXTURE_2D, __.GL.TEXTURE_MIN_FILTER, __.GL.NEAREST);
		__.GL.texParameteri(__.GL.TEXTURE_2D, __.GL.TEXTURE_MAG_FILTER, __.GL.NEAREST);
		return tex;
	}

	$.update_texture = function( tex, img ){
		if ( ! tex )
			tex = $.create_texture();
		__.GL.bindTexture(__.GL.TEXTURE_2D, tex);
		__.GL.texImage2D(
			__.GL.TEXTURE_2D , 0 , __.GL.RGBA      , // target , level , internalformat
			__.GL.RGBA       , __.GL.UNSIGNED_BYTE , // format , type
		img);
	}

	$.create_pixel = function( hex, w=1, h=1 ){
		hex = Q.math.clamp(hex, 0, 255) | 0;
		if ( w < 0 )  w = __.MAX_TEX_SIZE;
		if ( h < 0 )  h = __.MAX_TEX_SIZE;

		var size  = w * h * 4;
		var uint8 = new Uint8Array(size);
		for ( var i=0; i < size; i++ )
			uint8[i] = hex;

		var pix = {
			w : w ,
			h : h ,
			tex : $.create_texture() ,
		};
		__.GL.bindTexture(__.GL.TEXTURE_2D, pix.tex);
		__.GL.texImage2D(
			__.GL.TEXTURE_2D , 0 , __.GL.RGBA      , // target , level  , internalformat
			pix.w , pix.h    , 0                   , // width  , height , border
			__.GL.RGBA       , __.GL.UNSIGNED_BYTE , // format , type
			uint8
		);
		return pix;
	}

	$.read_RGBA = function(){
		var bw = __.GL.drawingBufferWidth;
		var bh = __.GL.drawingBufferHeight;
		var buf = new Uint8Array( bw * bh * 4 );
		__.GL.readPixels(0, 0, bw, bh, __.GL.RGBA, __.GL.UNSIGNED_BYTE, buf);

		var pix = new Uint8Array( 12 + (bw * bh * 4) );
		Q.binary.setint(pix, 0, 4, 0x41424752); // RGBA
		Q.binary.setint(pix, 4, 4, bw);
		Q.binary.setint(pix, 8, 4, bh);

		// vflip the image
		var row = bw * 4;
		for ( var dy=0; dy < bh; dy++ ){
			var dyy = 12 + (dy * row);
			var syy = (bh - 1 - dy) * row;

			for ( var x=0; x < row; x++ ){
				pix[dyy] = buf[syy];
				dyy++;
				syy++;
			}
		} // for ( var dy=0; dy < bh; dy++ )
		return pix;
	}

	//////////////////////////////

	$.enable_blend = function( blend ){
		if ( ! blend )
			return __.GL.disable(__.GL.BLEND);

		var c = blend.color;
		__.GL.blendColor(c[0], c[1], c[2], c[3]);

		var mode = blend.mode;
		if ( ! Array.isArray(mode) )
			return __.GL.disable(__.GL.BLEND);

		if ( mode.length === 6 ){
			__.GL.blendEquationSeperate(__.GL[ mode[0] ] , __.GL[ mode[1] ]);
			__.GL.blendFuncSeperate    (__.GL[ mode[2] ] , __.GL[ mode[3] ] , __.GL[ mode[4] ] , __.GL[ mode[5] ]);
			return __.GL.enable(__.GL.BLEND);
		}
		if ( mode.length === 3 ){
			__.GL.blendEquation(__.GL[ mode[0] ]);
			__.GL.blendFunc    (__.GL[ mode[1] ] , __.GL[ mode[2] ]);
			return __.GL.enable(__.GL.BLEND);
		}
		return __.GL.disable(__.GL.BLEND);
	}

	$.enable_depth = function( depth ){
		if ( ! depth ){
			__.GL.clear(__.GL.DEPTH_BUFFER_BIT);
			//__.GL.depthMask(true); // can write depth
			__.GL.clearDepth(1.0);
			return __.GL.disable(__.GL.DEPTH_TEST);
		}

		__.GL.depthFunc(__.GL[depth]);
		return __.GL.enable(__.GL.DEPTH_TEST);
	}

	$.enable_framebuffer = function( tex ){
		if ( ! tex ){
			__.GL.bindFramebuffer(__.GL.FRAMEBUFFER, null);
			return null;
		}

		var fb = __.GL.createFramebuffer();
		__.GL.bindFramebuffer     (__.GL.FRAMEBUFFER, fb);
		__.GL.framebufferTexture2D(__.GL.FRAMEBUFFER, __.GL.COLOR_ATTACHMENT0, __.GL.TEXTURE_2D, tex, 0);
		var t = __.GL.checkFramebufferStatus(__.GL.FRAMEBUFFER);
		if ( t === __.GL.FRAMEBUFFER_COMPLETE ){
			Q.func.log('framebuffer OK');
			return fb;
		}
		return Q.func.error('framebuffer failed',t);
	}

	$.clear = function(){
		__.GL.clear(__.GL.COLOR_BUFFER_BIT);
		//__.GL.colorMask(true , true , true , true); // can write red, green, blue, alpha
		__.GL.clearColor(0 , 0 , 0 , 0);
		__.GL.flush();
	}

	$.is_valid_constant = function(){
		for ( var i=0; i < arguments.length; i++ ){
			if ( ! __.GL[ arguments[i] ] )
				return false;
		}
		return true;
	}

	//////////////////////////////

	$.drawingbuffer_size = function( max ){
		return [ __.GL.drawingBufferWidth , __.GL.drawingBufferHeight ];
	}

	$.detect_max_texsize = function(){
		var tex = $.create_texture();
		__.GL.bindTexture(__.GL.TEXTURE_2D, tex);

		var maxsz = __.GL.getParameter( __.GL.MAX_TEXTURE_SIZE ) >> 1;
		var bw = __.GL.canvas.width;
		var bh = __.GL.canvas.height;

		if ( maxsz < 0 )
			maxsz = 0;
		while ( maxsz > 0 ){
			// test if reading texture at this size
			__.GL.texImage2D(
				__.GL.TEXTURE_2D , 0 , __.GL.RGBA      , // target , level  , internalformat
				maxsz , maxsz    , 0                   , // width  , height , border
				__.GL.RGBA       , __.GL.UNSIGNED_BYTE , // format , type
				null
			);
			// test if writing canvas at this size
			__.GL.canvas.width  = maxsz;
			__.GL.canvas.height = maxsz;

			var error = 0;
			error |= ( __.GL.getError()    !== __.GL.NO_ERROR            );
			error |= ( __.GL.canvas.width  >   __.GL.drawingBufferWidth  );
			error |= ( __.GL.canvas.height >   __.GL.drawingBufferHeight );
			if ( error === 0 )
				break;

			// has error, halved maxsz and test again
			maxsz >>= 1;
		} // while ( maxsz > 0 )

		// restore canvas size after testing
		__.GL.canvas.width  = bw;
		__.GL.canvas.height = bh;
		return maxsz;
	}

	$.max_texsize = function(){
		return __.MAX_TEX_SIZE;
	}
	$.is_max_texsize = function(w, h){
		if ( w > __.MAX_TEX_SIZE || h > __.MAX_TEX_SIZE )
			return false;
		return true;
	}

	$.canvas_size = function(){
		return [ __.GL.canvas.width * 0.5 , __.GL.canvas.height * 0.5 ];
	}

	$.is_canvas_resized = function(){
		// display.block = [w,h] , display.none = [0,0]
		var c = 0;
		c |= ( __.GL.canvas.width  !== __.GL.canvas.clientWidth  );
		c |= ( __.GL.canvas.height !== __.GL.canvas.clientHeight );

		if ( c ){
			__.GL.canvas.width  = __.GL.canvas.clientWidth;
			__.GL.canvas.height = __.GL.canvas.clientHeight;
		}
		return c;
	}

	//////////////////////////////

} // function QuadGL

	function QuadFunc(Q){
	var $ = this; // public
	var __ = {};  // private

	//////////////////////////////

	__.LOGS = [];
	$.log = function(){
		var arg = [].slice.call(arguments);
		var txt = JSON.stringify(arg);
		__.LOGS.unshift( txt );
		while ( __.LOGS.length > 20 )
			__.LOGS.pop();
		return true;
	}
	$.error = function(){
		var arg = [].slice.call(arguments);
		var txt = JSON.stringify(arg);
		__.LOGS.unshift( 'ERROR : ' + txt );
		while ( __.LOGS.length > 20 )
			__.LOGS.pop();
		return false;
	}
	$.console = function(){
		return __.LOGS.join("\n\n");
	}

	$.is_array = function( array, size ){
		if ( ! Array.isArray(array) )
			return false;
		if ( array.length !== size )
			return false;
		return true;
	}
	$.is_array_unique = function( array ){
		if ( ! Array.isArray(array) )
			return false;
		for ( var i=0; i < array.length; i++){
			var idx = array.indexOf( array[i] );
			if ( idx !== i )
				return false;
		}
		return true;
	}
	$.array_clean_null = function( list ){
		if ( ! Array.isArray(list) )
			return;
		var len = list.length;
		while ( len > 0 ){
			len--;
			if ( list[len] === 0 )
				list.splice(len, 1);
		} // while ( len > 0 )
	}
	$.array_clean_dups = function( list ){
		if ( ! Array.isArray(list) )
			return;
		var len = list.length;
		while ( len > 0 ){
			len--;
			if ( list.indexOf( list[len] ) !== len )
				list.splice(len, 1);
		} // while ( len > 0 )
	}
	$.array_number = function( size ){
		var array = [];
		for ( var i=0; i < size; i++ )
			array.push(i);
		return array;
	}

	$.is_undef = function( a ){
		return ( typeof a === 'undefined' );
	}
	$.file_extension = function( fn ){
		var ext = fn.split('.').pop();
		return ext.toLowerCase();
	}
	$.copy_object = function( obj ){
		return JSON.parse( JSON.stringify(obj) );
	}

	//////////////////////////////

	$.upload_promise = function( up, qdata ){
		var ext = $.file_extension(up.name);
		switch ( ext ){
			case 'zip':
				return new Promise(function(resolve, reject){
					var reader = new FileReader;
					reader.onload = function(){
						var list = Q.binary.zipread( reader.result );
						resolve(list);
					}
					reader.readAsArrayBuffer(up);
				}).then(function(list){
					var key = Object.keys(list);
					var pro = [];
					for ( var i=0; i < key.length; i++ ){
						var ext = $.file_extension( key[i] );
						var dat = list[ key[i] ];

						switch ( ext ){
							case 'quad':
								var text = Q.binary.uint2txt(dat);
								pro[i] = __.upload_handler(qdata, 'quad', key[i], text);
								break;
							case 'png':
								var data = 'data:image/png;base64,' + Q.binary.to_base64(dat);
								pro[i] = __.upload_handler(qdata, 'image', key[i], data);
								break;
						} // switch ( ext )
					} // for ( var i=0; i < key.length; i++ )
					return Promise.all(pro);
				});

			case 'quad':
				return new Promise(function(resolve, reject){
					var reader = new FileReader;
					reader.onload = function(){
						resolve(reader.result);
					}
					reader.readAsText(up);
				}).then(function(text){
					return __.upload_handler(qdata, 'quad', up.name, text);
				});

			case 'png':
				return new Promise(function(resolve, reject){
					var reader = new FileReader;
					reader.onload = function(){
						resolve(reader.result);
					}
					reader.readAsDataURL(up);
				}).then(function(data){
					return __.upload_handler(qdata, 'image', up.name, data);
				});
		} // switch ( ext )
		return 0;
	}

	__.is_rect_collide = function( rect, list ){
		function collide( rect1, rect2 ){
			if ( rect1[0] >= rect2[2] )  return false; // r1.x1 >= r2.x2 , over right
			if ( rect1[1] >= rect2[3] )  return false; // r1.y1 >= r2.y2 , over bottom
			if ( rect1[2] <= rect2[0] )  return false; // r1.x2 <= r2.x1 , over left
			if ( rect1[3] <= rect2[1] )  return false; // r1.y2 <= r2.y1 , over top
			return true;
		}
		for ( var i=0; i < list.length; i++ ){
			if ( ! list[i] )
				continue;
			var col = collide(rect, list[i].pos);
			if ( col )
				return true;
		}
		return false;
	}

	__.vram_posrect = function( vram, texsz, list ){
		for ( var y=0; y < vram.h; y += 0x80 ){
			var y2 = y + texsz[1];
			if ( y2 > vram.h )
				continue;

			for ( var x=0; x < vram.w; x += 0x80 ){
				if ( x === 0 && y === 0 ) // reserve white pixel for fog
					continue;
				var x2 = x + texsz[0];
				if ( x2 > vram.w )
					continue;

				var rect = [x , y , x2 , y2];
				var col = __.is_rect_collide(rect, list);
				if ( ! col )
					return rect;
			} // for ( var x = 0x80; x < vram.w; x += 0x80 )
		} // for ( var y = 0x80; y < vram.h; y += 0x80 )

		// failed to allocate VRAM
		return 0;
	}

	__.upload_handler = function( qdata, type, fname, data ){
		switch( type ){
			case 'quad':
				var quad   = JSON.parse(data);
				qdata.quad = __.quadfile_check(quad);
				qdata.name = fname.replace(/[^A-Za-z0-9]/g, '_');
				return $.log('UPLOAD quad', fname);

			case 'image':
				return new Promise(function(resolve, reject){
					var dummytex = Q.gl.create_pixel(255);
					var fnm = fname.match(/\.([0-9]+)\./);
					var tid = fnm[1];

					var img = new Image;
					img.onload = function(){
						resolve([tid,img]);
					}
					img.src = data;
				}).then(function(res){
					var tid = res[0];
					var img = res[1];

					var tex = Q.gl.create_texture();
					Q.gl.update_texture(tex, img);
					return [tid,tex,img.width,img.height];
				}).then(function(res){
					var tid = res[0];
					var tex = res[1];
					var w = res[2];
					var h = res[3];

					// remove loaded texture
					qdata.image[tid] = 0;
					var pos = __.vram_posrect( qdata.vram , [w,h] , qdata.image );
					if ( ! pos )
						return $.error('cannot fit texture into VRAM', [qdata.vram.w,qdata.vram.h] , [w,h] , qdata.image);

					Q.gl.enable_blend(0);
					Q.gl.draw_vram(qdata.vram, tex, pos);
					qdata.image[tid] = {
						pos  : pos,
						name : fname,
					};
					return $.log('UPLOAD image', tid, qdata.image[tid]);
				});
		} // switch( type )
		return 0;
	}

	__.key_fogquad = function( fog ){
		if ( typeof fog === 'string' ){
			var c = Q.math.css_color(fog);
			return [].concat(c, c, c, c);
		}
		if ( $.is_array(fog, 4) ){
			var c0 = Q.math.css_color( fog[0] );
			var c1 = Q.math.css_color( fog[1] );
			var c2 = Q.math.css_color( fog[2] );
			var c3 = Q.math.css_color( fog[3] );
			return [].concat(c0, c1, c2, c3);
		}
		// default solid white
		return [1,1,1,1 , 1,1,1,1 , 1,1,1,1 , 1,1,1,1];
	}

	__.quadfile_check = function( quad ){
		quad.blend     = quad.blend     || [];
		quad.slot      = quad.slot      || [];
		quad.hitbox    = quad.hitbox    || [];
		quad.keyframe  = quad.keyframe  || [];
		quad.animation = quad.animation || [];
		quad.skeleton  = quad.skeleton  || [];
		quad.__MIX     = [];

		var ent;
		function nullent(arr,k){
			arr[k] = 0;
		}

		quad.blend.forEach(function(bv,bk){
			var valid = Q.gl.is_valid_constant.apply(null, bv.mode);
			if ( ! valid )
				return nullent(quad.blend, bk);
			if ( bv.mode.length !== 6 && bv.mode.length !== 3 )
				return nullent(quad.blend, bk);
			quad.blend[bk] = {
				'mode'  : bv.mode,
				'name'  : bv.name || 'blend ' + bk,
				'color' : Q.math.css_color( bv.color ),
			};
		}); // quad.blend.forEach

		quad.hitbox.forEach(function(hv,hk){
			if ( ! Array.isArray(hv.layer) )
				return nullent(quad.hitbox, hk);
			var is_null = true;
			hv.layer.forEach(function(lv,lk){
				if ( ! $.is_array(lv.hitquad, 8) )
					return nullent(hv.layer, lk);
				is_null = false;
				hv.layer[lk] = {
					'debug'   : lv.debug || 0,
					'hitquad' : lv.hitquad,
				};
			}); // hv.layer.forEach
			if ( is_null )
				return nullent(quad.hitbox, hk);
			ent = {
				'debug' : hv.debug || 0,
				'name'  : hv.name  || 'hitbox '+ hk,
				'layer' : hv.layer,
			};
			quad.hitbox[hk] = ent;
		}); // quad.hitbox.forEach

		quad.keyframe.forEach(function(kv,kk){
			if ( ! Array.isArray(kv.layer) )
				return nullent(quad.keyframe, kk);
			var is_null = true;
			kv.layer.forEach(function(lv,lk){
				if ( ! $.is_array(lv.dstquad, 8) )
					return nullent(kv.layer, lk);
				is_null = false;
				ent = {
					'debug'    : lv.debug || 0,
					'dstquad'  : lv.dstquad,
					'tex_id'   : -1,
					'blend_id' : -1,
					'fogquad'  : __.key_fogquad( lv.fogquad ),
					'srcquad'  : 0,
				};
				if ( ! $.is_undef(lv.blend_id) )  ent.blend_id = lv.blend_id | 0; // 0 is valid
				if ( ! $.is_undef(lv.tex_id  ) )  ent.tex_id   = lv.tex_id   | 0; // 0 is valid
				if ( $.is_array(lv.srcquad, 8) )
					ent.srcquad = lv.srcquad;
				kv.layer[lk] = ent;
			}); // kv.layer.forEach
			if ( is_null )
				return nullent(quad.keyframe, kk);
			ent = {
				'debug'  : kv.debug || 0,
				'name'   : kv.name  || 'keyframe '+ kk,
				'layer'  : kv.layer,
				'order'  : kv.order,
				'__RECT' : 0,
			};
			if ( ! $.is_array_unique(ent.order) )
				ent.order = $.array_number( kv.layer.length );
			quad.keyframe[kk] = ent;
		}); // quad.keyframe.forEach

		quad.animation.forEach(function(av,ak){
			if ( ! Array.isArray(av.timeline) )
				return nullent(quad.animation, ak);
			av.timeline.forEach(function(tv,tk){
				if ( tv.time < 1 )
					return nullent(av.timeline, tk);
				ent = {
					'debug'        : tv.debug  || 0,
					'time'         : tv.time,
					'attach'       : tv.attach || 0 ,
					'matrix'       : 0,
					'color'        : Q.math.css_color(tv.color),
					'matrix_mix'   : ( tv.matrix_mix   ) ? true : false,
					'color_mix'    : ( tv.color_mix    ) ? true : false,
					'keyframe_mix' : ( tv.keyframe_mix ) ? true : false,
					'hitbox_mix'   : ( tv.hitbox_mix   ) ? true : false,
				};
				if ( $.is_array(tv.matrix, 16) )
					ent.matrix = tv.matrix;
				av.timeline[tk] = ent;
			}); // av.timeline.forEach
			$.array_clean_null(av.timeline);
			if ( av.timeline.length < 1 )
				return nullent(quad.animation, ak);
			ent = {
				'debug'    : av.debug || 0,
				'name'     : av.name  || 'animation' + ak,
				'timeline' : av.timeline,
				'loop_id'  : -1,
				'__RECT'   : 0,
			};
			if ( ! $.is_undef(av.loop_id) )  ent.loop_id = av.loop_id; // 0 is valid
			quad.animation[ak] = ent;
		}); // quad.animation.forEach

		quad.skeleton.forEach(function(sv,sk){
			if ( ! Array.isArray(sv.bone) || sv.bone.length < 1 )
				return nullent(quad.skeleton, sk);
			sv.bone.forEach(function(bv,bk){
				ent = {
					'debug'     : bv.debug  || 0,
					'name'      : bv.name   || 'bone ' + bk,
					'attach'    : bv.attach || 0,
				};
				sv.bone[bk] = ent;
			}); // sv.bone.forEach
			quad.skeleton[sk] = {
				'debug'  : sv.debug || 0,
				'name'   : sv.name  || 'skeleton ' + sk,
				'bone'   : sv.bone,
				'__RECT' : 0,
			};
		}); // quad.skeleton.forEach

		return quad;
	}

	//////////////////////////////

	__.draw_lines = function( qdata, layer, mat4, quad ){
		var clines = [];

		var debug = [];
		var did, dbg;
		layer.forEach(function(lv,lk){
			if ( ! lv )
				return;

			dbg = JSON.stringify(lv.debug);
			did = debug.indexOf(dbg);
			if ( did < 0 ){
				did = debug.length;
				debug.push(dbg);
				clines[did] = [];
			}

			var dst = Q.math.quad_multi4(mat4, lv[quad]);
			clines[did] = clines[did].concat(dst);
		});

		var color = [
			[1,0,0,1] , [0,1,0,1] , [0,0,1,1] , // rgb
			[0,1,1,1] , [1,0,1,1] , [1,1,0,1] , // cmy
			[0,0,0,1] , [1,1,1,1] ,             // black white
			[0.5,0  ,0  ,1] , [0  ,0.5,0  ,1] , [0  ,0  ,0.5,1] , // 0.5 rgb
			[0  ,0.5,0.5,1] , [0.5,0  ,0.5,1] , [0.5,0.5,0  ,1] , // 0.5 cmy
			[0.5,0.5,0.5,1] , // gray
		];

		Q.gl.enable_blend(0);
		clines.forEach(function(cv,ck){
			var cid = qdata.line_index % color.length;
			Q.gl.draw_line(cv, color[cid]);

			qdata.line_index++;
			qdata.is_draw = true;
		});
	}

	__.draw_hitbox = function( qdata, hid, mat4 ){
		var layer = qdata.quad.hitbox[hid].layer;
		__.draw_lines(qdata, layer, mat4, 'hitquad');
	}

	//////////////////////////////

	__.draw_keyframe_tex = function( qdata, layer, order, mat4, color ){
		var dummysrc = [0,0 , 0,0 , 0,0 , 0,0];

		var zrate = 1.0 / (layer.length + 1);
		var buf_list = [];
		var depth = 1.0;
		//console.log('order',order);

		// draw layers by keyframe order
		order.forEach(function(ov){
			var lv = layer[ov];
			if ( ! lv )
				return;
			depth -= zrate;

			var bid = lv.blend_id | 0;
			if ( ! buf_list[bid] )
				buf_list[bid] = { dst:[] , src:[] , fog:[] , z:[] };
			var ent = buf_list[bid];

			if ( lv.tex_id < 0 || ! qdata.image[lv.tex_id] )
				var src = dummysrc;
			else
				var src = Q.math.vram_srcquad(lv.srcquad, qdata.image[lv.tex_id].pos);
			ent.src = ent.src.concat(src);

			var dst = Q.math.quad_multi4(mat4, lv.dstquad);
			var xyz = Q.math.perspective_quad(dst);
			ent.dst = ent.dst.concat(xyz);

			var clr = Q.math.fog_multi4(color, lv.fogquad);
			ent.fog = ent.fog.concat(clr);

			ent.z = ent.z.concat([depth , depth , depth , depth]);
		});
		//console.log('buf_list',buf_list);

		Q.gl.enable_depth('LESS');
		buf_list.forEach(function(bv,bk){
			if ( ! bv || ! qdata.quad.blend[bk] )
				return;
			qdata.is_draw = true;
			Q.gl.enable_blend ( qdata.quad.blend[bk] );
			Q.gl.draw_keyframe( bv.dst, bv.src, bv.fog, bv.z, qdata.vram );
		});
		Q.gl.enable_depth(0);
	}

	__.draw_keyframe = function( qdata, kid, mat4, color ){
		var key = qdata.quad.keyframe[kid];
		if ( qdata.is_lines )
			return __.draw_lines(qdata, key.layer, mat4, 'dstquad');
		else
			return __.draw_keyframe_tex(qdata, key.layer, key.order, mat4, color);
	}

	//////////////////////////////

	__.draw_MIX = function( qdata, id, mat4, color ){
		var mix = qdata.quad.__MIX[id];
		mix.forEach(function(mv,mk){
			switch ( mv.type ){
				case 'keyframe':
					if ( qdata.is_lines )
						return __.draw_lines(qdata, mv.layer, mat4, 'dstquad');
					else
						return __.draw_keyframe_tex(qdata, mv.layer, mv.order, mat4, color);
				case 'hitbox':
					if ( ! qdata.is_hits )
						return;
					return __.draw_lines(qdata, mv.layer, mat4, 'hitquad');
			} // switch ( mv.type )
		});
	}

	__.mix_attach = function( qdata, cur, nxt, rate, keymix, hitmix ){
		var mixslot = [];

		function nextlayer( next, s ){
			if ( next.type === s )
				return qdata.quad[s][ next.id ].layer;
			if ( next.type === 'slot' ){
				var slot = qdata.quad.slot[ next.id ];
				for ( var i=0; i < slot.length; i++ ){
					if ( slot[i].type === s )
						return qdata.quad[s][ slot[i].id ].layer;
				}
			}
			return 0;
		}
		function addmixslot( mcur, mnxt ){
			switch( mcur.type ){
				case 'slot':
					var slot = qdata.quad.slot[ cur.id ];
					slot.forEach(function(sv,sk){
						addmixslot(sv, mnxt);
					});
					return;
				case 'keyframe':
				case 'hitbox':
					var curlayer = qdata.quad[ mcur.type ][ mcur.id ].layer;
					if ( ! curlayer )
						return;
					var ent = {
						'type'  : mcur.type,
						'layer' : $.copy_object( curlayer ),
					};
					if ( mcur.type === 'keyframe' )
						ent.order = qdata.quad[ mcur.type ][ mcur.id ].order;

					var mix = 0;
					mix |= ( mcur.type === 'keyframe' && keymix );
					mix |= ( mcur.type === 'hitbox'   && hitmix );
					if ( ! mix )
						return mixslot.push(ent);

					var nxtlayer = nextlayer(mnxt, mcur.type);
					if ( ! nxtlayer )
						return mixslot.push(ent);
					if ( curlayer.length !== nxtlayer.length )
						return mixslot.push(ent);

					ent.layer.forEach(function(lv,lk){
						if ( ! lv || ! nxtlayer[lk] )
							return;
						if ( keymix && lv.dstquad && nxtlayer[lk].dstquad )
							lv.dstquad = Q.math.quad_mix( rate, curlayer[lk].dstquad, nxtlayer[lk].dstquad );
						if ( hitmix && lv.hitquad && nxtlayer[lk].hitquad )
							lv.hitquad = Q.math.quad_mix( rate, curlayer[lk].hitquad, nxtlayer[lk].hitquad );
						if ( keymix && lv.fogquad && nxtlayer[lk].fogquad )
							lv.fogquad = Q.math.fog_mix ( rate, curlayer[lk].fogquad, nxtlayer[lk].fogquad );
					});
					return mixslot.push(ent);
			} // switch( mcur.type )
		}
		addmixslot(cur, nxt);

		// return attach object
		var id = qdata.quad.__MIX.length;
		qdata.quad.__MIX.push(mixslot);
		return {
			'type' : '__MIX',
			'id'   : id,
		};
	}

	__.anim_time_index = function( fps, anim ){
		var len = anim.timeline.length;
		var cur = 0;
		while (1){
			fps -= anim.timeline[cur].time;
			if ( fps < 0 )
				return [cur,-fps];

			cur++;
			if ( cur >= len ){
				if ( anim.loop_id < 0 )
					return [-1,0];
				cur = anim.loop_id;
			}
		} // while (1)
	}

	__.anim_current = function( qdata, aid, mat4, color ){
		var ret = {
			attach : 0,
			mat4   : mat4,
			color  : color,
		}

		// check for valid range
		if ( qdata.anim_fps < 0 )
			return ret;
		var anim = qdata.quad.animation[aid];

		// get current frame
		var t = __.anim_time_index(qdata.anim_fps, anim);
		var curid = t[0];
		if ( curid < 0 )
			return ret;
		var cur = anim.timeline[curid];

		// get next frame
		var nxtid = curid + 1;
		if ( nxtid >= anim.timeline.length ){
			if ( anim.loop_id < 0 )
				nxtid = curid;
			else
				nxtid = anim.loop_id;
		}
		var nxt = anim.timeline[nxtid];

		// nothing to mix
		ret.attach = cur.attach;
		if ( curid === nxtid ){
			ret.mat4  = Q.math.matrix_multi44( ret.mat4 , cur.matrix );
			ret.color = Q.math.vec4_multi    ( ret.color, cur.color  );
			return ret;
		}

		// mixing tests
		var m4, c4;
		var rate = t[1] / cur.time;

		// mix matrix
		if ( cur.matrix_mix )
			m4 = Q.math.matrix_mix( rate, cur.matrix, nxt.matrix );
		else
			m4 = cur.matrix;
		ret.mat4 = Q.math.matrix_multi44( ret.mat4 , m4 );

		// mix color
		if ( cur.color_mix )
			c4 = Q.math.color_mix( rate, cur.color , nxt.color  );
		else
			c4 = cur.color;
		ret.color = Q.math.vec4_multi( ret.color, c4 );

		// layer mixing test
		if ( ! cur.keyframe_mix && ! cur.hitbox_mix )
			return ret;

		ret.attach = __.mix_attach(qdata, cur.attach, nxt.attach, rate, cur.keyframe_mix, cur.hitbox_mix);
		return ret;
	}

	//////////////////////////////

	__.draw_skeleton = function( qdata, sid, mat4, color ){
		var bone = qdata.quad.skeleton[sid].bone;
		bone.forEach(function(bv,bk){
			__.draw_attach(qdata, bv.attach, mat4, color);
		});
	}

	//////////////////////////////

	$.is_valid_attach = function( qdata, type, id ){
		if ( ! Array.isArray( qdata.quad[ type ] ) )
			return false;
		if ( ! qdata.quad[ type ][ id ] )
			return false;
		return true;
	}

	__.draw_attach = function( qdata, attach, mat4, color ){
		if ( ! $.is_valid_attach(qdata, attach.type, attach.id) )
			return;
		switch ( attach.type ){
			case 'keyframe':
				return __.draw_keyframe( qdata, attach.id, mat4, color );
			case 'animation':
				var t = __.anim_current( qdata, attach.id, mat4, color );
				if ( ! t.attach )
					return;
				return __.draw_attach( qdata, t.attach, t.mat4, t.color );
			case 'slot':
				qdata.quad.slot[ attach.id ].forEach(function(sv,sk){
					__.draw_attach(qdata, sv, mat4, color);
				});
				return;
			case 'hitbox':
				if ( ! qdata.is_hits )
					return;
				return __.draw_hitbox( qdata, attach.id, mat4 );
			case 'skeleton':
				return __.draw_skeleton( qdata, attach.id, mat4, color );
			case '__MIX':
				return __.draw_MIX( qdata, attach.id, mat4, color );
			case 'list':
				var qid = qdata.quad.list[ attach.id ];
				if ( $.is_undef(qid) || qid < 0 )
					return;
				return $.qdata_draw( qdata.list[qid], mat4, color );
		} // switch ( attach.type )
	}

	$.qdata_draw = function( qdata, mat4, color ){
		if ( ! qdata.quad )
			return;
		var m4 = Q.math.matrix_multi44( mat4, qdata.matrix );
		var c4 = Q.math.vec4_multi(color, qdata.color);
		return __.draw_attach(qdata, qdata.attach, m4, c4);
	}

	$.qdata_clear = function( qdata ){
		if ( ! qdata.quad )
			return;
		Q.gl.clear();
		qdata.is_draw = false;
		qdata.line_index = 0;
		qdata.quad.__MIX = [];
	}

	$.viewer_camera = function( qdata, autozoom ){
		var canvsz = Q.gl.canvas_size();

		qdata.zoom = 1.0;
		var movex = canvsz[0] * 0  ; // no change
		var movey = canvsz[1] * 0.5; // half downward

		if ( autozoom ){
			var sprsize = Q.export.rect_attach(qdata, qdata.attach.type, qdata.attach.id);
			if ( sprsize ){
				if ( sprsize[0] < 0 || sprsize[1] < 0 ){
					// is sprite , 0,0 is at center
					// x1 or y1 is negative
					var symm = Q.math.rect_symmetry(sprsize);
					var zoomx = canvsz[0] / symm[0];
					var zoomy = canvsz[1] / symm[1];
					qdata.zoom = ( zoomx < zoomy ) ? zoomx : zoomy;
				}
				else {
					// is map , 0,0 is top-left
					// x1 and y1 is positive
					var hw = (sprsize[2] - sprsize[0]) * 0.5;
					var hh = (sprsize[3] - sprsize[1]) * 0.5;
					var zoomx = canvsz[0] / hw;
					var zoomy = canvsz[1] / hh;
					qdata.zoom = ( zoomx < zoomy ) ? zoomx : zoomy;
					movex = (sprsize[0] - hw) * qdata.zoom;
					movey = (sprsize[1] - hh) * qdata.zoom;
				}
			} // if ( sprsize )
		} // if ( autozoom )

		var m4 = Q.math.matrix4();
		m4[0+3] = movex;
		m4[4+3] = movey;

		m4[0+0] = qdata.zoom;
		m4[4+1] = qdata.zoom;
		if ( qdata.is_flipx )  m4[0+0] = -m4[0+0];
		if ( qdata.is_flipy )  m4[4+1] = -m4[4+1];
		return m4;
	}

	$.is_changed = function( qdata ){
		var c = 0;
		c |= ( qdata.prev[0] !== qdata.attach.type );
		c |= ( qdata.prev[1] !== qdata.attach.id   );
		c |= ( qdata.prev[2] !== qdata.anim_fps    );
		c |= ( qdata.prev[3] !== qdata.is_lines    );
		c |= ( qdata.prev[4] !== qdata.is_hits     );
		c |= ( qdata.prev[5] !== qdata.is_flipx    );
		c |= ( qdata.prev[6] !== qdata.is_flipy    );
		c |= ( qdata.prev[7] !== qdata.zoom        );

		if ( c ){
			qdata.prev = [
				qdata.attach.type ,
				qdata.attach.id   ,
				qdata.anim_fps    ,
				qdata.is_lines    ,
				qdata.is_hits     ,
				qdata.is_flipx    ,
				qdata.is_flipy    ,
				qdata.zoom        ,
			];
		}
		return c;
	}

	//////////////////////////////

} // function QuadFunc(Q)

	function QuadMath(Q){
	var $ = this; // public
	//var __ = {};  // private

	//////////////////////////////

	$.is_int_pow2 = function( int ){
		// 100 & ff === 0
		var rem = int & (int - 1);
		return ( rem === 0 );
	}

	$.clamp = function( n, min, max ){
		if ( n < min )  return min;
		if ( n > max )  return max;
		return n;
	}

	$.rect_symmetry = function( rect ){
		var abs = [
			Math.abs(rect[0]) , Math.abs(rect[1]) ,
			Math.abs(rect[2]) , Math.abs(rect[3]) ,
		];
		var maxx = ( abs[0] > abs[2] ) ? abs[0] : abs[2];
		var maxy = ( abs[1] > abs[3] ) ? abs[1] : abs[3];
		return [ maxx , maxy ];
	}

	$.vram_srcquad = function( quad, pos ){
		if ( ! quad )  return 0; // fog color only
		var xy4 = [0,0 , 0,0 , 0,0 , 0,0];
		for ( var i=0; i < 8; i += 2 ){
			xy4[i+0] = quad[i+0] + pos[0];
			xy4[i+1] = quad[i+1] + pos[1];
		}
		return xy4;
	}

	$.css_color = function( css ){
		// css = '#rrggbbaa'
		if ( typeof css !== 'string' || ! /^#[0-9a-fA-F]{8}$/.test(css) )
			return [1,1,1,1];

		var div = 1.0 / 255;
		var rgba = [
			parseInt( css.substring(1,3) , 16 ) * div ,
			parseInt( css.substring(3,5) , 16 ) * div ,
			parseInt( css.substring(5,7) , 16 ) * div ,
			parseInt( css.substring(7,9) , 16 ) * div ,
		];
		return rgba;
	}

	//////////////////////////////

	$.vec_resize = function( len, vec ){
		if ( ! Array.isArray(vec) )
			return;
		while ( vec.length < len )
			vec.push(1);
		while ( vec.length > len ){
			var last = vec.pop() || 0;
			var z = ( last === 0 ) ? 0 : 1.0 / last;
			for ( var i=0; i < vec.length; i++ )
				vec[i] *= z;
		}
	}

	$.vec_multi = function( v, f ){
		if ( ! Array.isArray(v) )
			return;
		for ( var i=0; i < v.length; i++ )
			v[i] *= f;
	}

	$.vec4_multi = function( v1, v2 ){
		var v4 = [
			v1[0] * v2[0],
			v1[1] * v2[1],
			v1[2] * v2[2],
			v1[3] * v2[3],
		];
		return v4;
	}

	//////////////////////////////

	$.matrix4 = function(){
		var m4 = [
			1,0,0,0,
			0,1,0,0,
			0,0,1,0,
			0,0,0,1,
		];
		return m4;
	}

	$.matrix_multi12 = function( v, m ){
		$.vec_resize(2,v);
		var vm = [
			v[0]*m[0] + v[1]*m[2] ,
			v[0]*m[1] + v[1]*m[3] ,
		];
		return vm;
	}

	$.matrix_multi13 = function( v, m ){
		$.vec_resize(3,v);
		var vm = [
			v[0]*m[0] + v[1]*m[3] + v[2]*m[6] ,
			v[0]*m[1] + v[1]*m[4] + v[2]*m[7] ,
			v[0]*m[2] + v[1]*m[5] + v[2]*m[8] ,
		];
		return vm;
	}

	$.matrix_multi14 = function( v, m ){
		$.vec_resize(4,v);
		var vm = [
			v[0]*m[0] + v[1]*m[4] + v[2]*m[ 8] + v[3]*m[12] ,
			v[0]*m[1] + v[1]*m[5] + v[2]*m[ 9] + v[3]*m[13] ,
			v[0]*m[2] + v[1]*m[6] + v[2]*m[10] + v[3]*m[14] ,
			v[0]*m[3] + v[1]*m[7] + v[2]*m[11] + v[3]*m[15] ,
		];
		return vm;
	}

	$.matrix_multi21 = function( m, v ){
		$.vec_resize(2,v);
		var mv = [
			m[0]*v[0] + m[1]*v[1] ,
			m[2]*v[0] + m[3]*v[1] ,
		];
		return mv;
	}

	$.matrix_multi31 = function( m, v ){
		$.vec_resize(3,v);
		var mv = [
			m[0]*v[0] + m[1]*v[1] + m[2]*v[2] ,
			m[3]*v[0] + m[4]*v[1] + m[5]*v[2] ,
			m[6]*v[0] + m[7]*v[1] + m[8]*v[2] ,
		];
		return mv;
	}

	$.matrix_multi41 = function( m, v ){
		$.vec_resize(4,v);
		var mv = [
			m[ 0]*v[0] + m[ 1]*v[1] + m[ 2]*v[2] + m[ 3]*v[3] ,
			m[ 4]*v[0] + m[ 5]*v[1] + m[ 6]*v[2] + m[ 7]*v[3] ,
			m[ 8]*v[0] + m[ 9]*v[1] + m[10]*v[2] + m[11]*v[3] ,
			m[12]*v[0] + m[13]*v[1] + m[14]*v[2] + m[15]*v[3] ,
		];
		return mv;
	}

	$.matrix_multi22 = function( m2a, m2b ){
		if ( ! m2a && ! m2b )  return 0;
		if ( ! m2a )  return m2b;
		if ( ! m2b )  return m2a;
		var m2 = [
			m2a[0]*m2b[0] + m2a[1]*m2b[2],
			m2a[0]*m2b[1] + m2a[1]*m2b[3],

			m2a[2]*m2b[0] + m2a[3]*m2b[2],
			m2a[2]*m2b[1] + m2a[3]*m2b[3],
		];
		return m2;
	}

	$.matrix_multi33 = function( m3a, m3b ){
		if ( ! m3a && ! m3b )  return 0;
		if ( ! m3a )  return m3b;
		if ( ! m3b )  return m3a;
		var m3 = [
			m3a[0]*m3b[0] + m3a[1]*m3b[3] + m3a[2]*m3b[6],
			m3a[0]*m3b[1] + m3a[1]*m3b[4] + m3a[2]*m3b[7],
			m3a[0]*m3b[2] + m3a[1]*m3b[5] + m3a[2]*m3b[8],

			m3a[3]*m3b[0] + m3a[4]*m3b[3] + m3a[5]*m3b[6],
			m3a[3]*m3b[1] + m3a[4]*m3b[4] + m3a[5]*m3b[7],
			m3a[3]*m3b[2] + m3a[4]*m3b[5] + m3a[5]*m3b[8],

			m3a[6]*m3b[0] + m3a[7]*m3b[3] + m3a[8]*m3b[6],
			m3a[6]*m3b[1] + m3a[7]*m3b[4] + m3a[8]*m3b[7],
			m3a[6]*m3b[2] + m3a[7]*m3b[5] + m3a[8]*m3b[8],
		];
		return m3;
	}

	$.matrix_multi44 = function( m4a, m4b ){
		if ( ! m4a && ! m4b )  return 0;
		if ( ! m4a )  return m4b;
		if ( ! m4b )  return m4a;
		var m4 = [
			m4a[ 0]*m4b[0] + m4a[ 1]*m4b[4] + m4a[ 2]*m4b[ 8] + m4a[ 3]*m4b[12],
			m4a[ 0]*m4b[1] + m4a[ 1]*m4b[5] + m4a[ 2]*m4b[ 9] + m4a[ 3]*m4b[13],
			m4a[ 0]*m4b[2] + m4a[ 1]*m4b[6] + m4a[ 2]*m4b[10] + m4a[ 3]*m4b[14],
			m4a[ 0]*m4b[3] + m4a[ 1]*m4b[7] + m4a[ 2]*m4b[11] + m4a[ 3]*m4b[15],

			m4a[ 4]*m4b[0] + m4a[ 5]*m4b[4] + m4a[ 6]*m4b[ 8] + m4a[ 7]*m4b[12],
			m4a[ 4]*m4b[1] + m4a[ 5]*m4b[5] + m4a[ 6]*m4b[ 9] + m4a[ 7]*m4b[13],
			m4a[ 4]*m4b[2] + m4a[ 5]*m4b[6] + m4a[ 6]*m4b[10] + m4a[ 7]*m4b[14],
			m4a[ 4]*m4b[3] + m4a[ 5]*m4b[7] + m4a[ 6]*m4b[11] + m4a[ 7]*m4b[15],

			m4a[ 8]*m4b[0] + m4a[ 9]*m4b[4] + m4a[10]*m4b[ 8] + m4a[11]*m4b[12],
			m4a[ 8]*m4b[1] + m4a[ 9]*m4b[5] + m4a[10]*m4b[ 9] + m4a[11]*m4b[13],
			m4a[ 8]*m4b[2] + m4a[ 9]*m4b[6] + m4a[10]*m4b[10] + m4a[11]*m4b[14],
			m4a[ 8]*m4b[3] + m4a[ 9]*m4b[7] + m4a[10]*m4b[11] + m4a[11]*m4b[15],

			m4a[12]*m4b[0] + m4a[13]*m4b[4] + m4a[14]*m4b[ 8] + m4a[15]*m4b[12],
			m4a[12]*m4b[1] + m4a[13]*m4b[5] + m4a[14]*m4b[ 9] + m4a[15]*m4b[13],
			m4a[12]*m4b[2] + m4a[13]*m4b[6] + m4a[14]*m4b[10] + m4a[15]*m4b[14],
			m4a[12]*m4b[3] + m4a[13]*m4b[7] + m4a[14]*m4b[11] + m4a[15]*m4b[15],
		];
		return m4;
	}

	$.matrix_det2 = function( m2 ){
		return (m2[0]*m2[3] - m2[1]*m2[2]);
	}

	$.matrix_inv2 = function( m2 ){
		var det = $.matrix_det2(m2);
		if ( det === 0 )
			return 0;
		var det_inv = 1.0 / det;
		var mco = [
			 m2[3] * det_inv , -m2[1] * det_inv ,
			-m2[2] * det_inv ,  m2[0] * det_inv ,
		];
		return mco;
	}

	$.matrix_inv3 = function( m3 ){
		// | 0 1 2 |
		// | 3 4 5 |
		// | 6 7 8 |
		var mdet = [
			$.matrix_det2([ m3[4],m3[5],m3[7],m3[8] ]),
			$.matrix_det2([ m3[3],m3[5],m3[6],m3[8] ]),
			$.matrix_det2([ m3[3],m3[4],m3[6],m3[7] ]),

			$.matrix_det2([ m3[1],m3[2],m3[7],m3[8] ]),
			$.matrix_det2([ m3[0],m3[2],m3[6],m3[8] ]),
			$.matrix_det2([ m3[0],m3[1],m3[6],m3[7] ]),

			$.matrix_det2([ m3[1],m3[2],m3[4],m3[5] ]),
			$.matrix_det2([ m3[0],m3[2],m3[3],m3[5] ]),
			$.matrix_det2([ m3[0],m3[1],m3[3],m3[4] ]),
		];

		var mco = [
			 mdet[0] , -mdet[3] ,  mdet[6] ,
			-mdet[1] ,  mdet[4] , -mdet[7] ,
			 mdet[2] , -mdet[5] ,  mdet[8] ,
		];

		var det = m3[0]*mco[0] + m3[1]*mco[3] + m3[2]*mco[6];
		if ( det === 0 )
			return 0;
		var det_inv = 1.0 / det;
		var i = 9;
		while ( i > 0 ){
			i--;
			mco[i] *= det_inv;
		}
		return mco;
	}

	//////////////////////////////

	$.cross = function( a, b ){
		$.vec_resize(3,a);
		$.vec_resize(3,b);
		// x = y1*z2 - y2*z1
		// y = z1*x2 - z2*x1
		// z = x1*y2 - x2*y1
		var x = a[1]*b[2] - b[1]*a[2];
		var y = a[2]*b[0] - b[2]*a[0];
		var z = a[0]*b[1] - b[0]*a[1];
		return [x,y,z];
	}

	$.perspective_mat3 = function( quad ){
		var v = [
			[ quad[0],quad[1],1 ],
			[ quad[2],quad[3],1 ],
			[ quad[4],quad[5],1 ],
			[ quad[6],quad[7],1 ],
		];

		// 0 1
		// 3 2
		var c = [
			$.cross( $.cross(v[0],v[2]) , $.cross(v[1],v[3]) ), // corner-corner
			$.cross( $.cross(v[0],v[1]) , $.cross(v[3],v[2]) ), //    top-bottom
			$.cross( $.cross(v[0],v[3]) , $.cross(v[1],v[2]) ), //   left-right
		];
		var m3 = [
			c[0][0] , c[1][0] , c[2][0] ,
			c[0][1] , c[1][1] , c[2][1] ,
			c[0][2] , c[1][2] , c[2][2] ,
		];
		return m3;
	}

	$.perspective_quad = function( dst ){
		//   | H1x H2x H3x |   | h1x h2x h3x |
		// M | H1y H2y H3y | = | h1y h2y h3y |
		//   | H1z H2z H3z |   | h1z h2z h3z |
		//                MH = h
		//                M  = hH^-1
		var h = $.perspective_mat3(dst);

		// var H    = pre-computed
		// var Hinv = pre-computed
		var H_inv = [
			 0     , 0     ,  0.005 ,
			-0.001 , 0     ,  0.015 ,
			 0     , 0.001 , -0.015 ,
		];
		var M3 = $.matrix_multi33(h, H_inv);

		var t = [
			$.matrix_multi31( M3, [10,10] ),
			$.matrix_multi31( M3, [20,10] ),
			$.matrix_multi31( M3, [20,20] ),
			$.matrix_multi31( M3, [10,20] ),
		];
		return [].concat(t[0],t[1],t[2],t[3]);
	}
	


	//////////////////////////////

	$.matrix_mix = function( rate, cur, next ){
		if ( ! cur && ! next )  return 0; // both identidy matrix
		if ( ! cur  )  cur  = $.matrix4();
		if ( ! next )  next = $.matrix4();
		// 4/4 = rate 1    = cur * 1    + next * 0
		// 3/4 = rate 0.75 = cur * 0.75 + next * 0.25
		// 2/4 = rate 0.5  = cur * 0.5  + next * 0.5
		// 1/4 = rate 0.25 = cur * 0.25 + next * 0.75
		// 0/4 = rate 0    = cur * 0    + next * 1
		var rev = 1.0 - rate;
		var m4  = [0,0,0,0 , 0,0,0,0 , 0,0,0,0 , 0,0,0,0];
		for ( var i=0; i < 16; i++ )
			m4[i] = (cur[i] * rate) + (next[i] * rev);
		return m4;
	}

	$.color_mix = function( rate, cur, next ){
		if ( ! cur || ! next )
			Q.func.error('math.color_mix',cur,next);
		var rev = 1.0 - rate;
		var c4  = [0,0,0,0];
		for ( var i=0; i < 4; i++ )
			c4[i] = (cur[i] * rate) + (next[i] * rev);
		return c4;
	}

	$.quad_mix = function( rate, cur, next ){
		if ( ! cur || ! next )
			Q.func.error('math.quad_mix',cur,next);
		var rev = 1.0 - rate;
		var xy4 = [0,0 , 0,0 , 0,0 , 0,0];
		for ( var i=0; i < 8; i++ )
			xy4[i] = (cur[i] * rate) + (next[i] * rev);
		return xy4;
	}

	$.fog_mix = function( rate, cur, next ){
		if ( ! cur || ! next )
			Q.func.error('math.fog_mix',cur,next);
		var rev = 1.0 - rate;
		var f4  = [0,0,0,0 , 0,0,0,0 , 0,0,0,0 , 0,0,0,0];
		for ( var i=0; i < 16; i++ )
			f4[i] = (cur[i] * rate) + (next[i] * rev);
		return f4;
	}

	// order matters
	//   (A*B)*C === A*(B*C)
	//    A*B    !== B*A
	$.rect_multi4 = function( mat4, rect ){
		if ( ! mat4 )  return rect; // mat4=0 is identidy matrix , rect=no change
		var xy2 = [0,0 , 0,0];
		for ( var i=0; i < 4; i += 2 ){
			var x = rect[i+0];
			var y = rect[i+1];
			xy2[i+0] = mat4[0]*x + mat4[1]*y + mat4[2] + mat4[3];
			xy2[i+1] = mat4[4]*x + mat4[5]*y + mat4[6] + mat4[7];
		}
		return xy2;
	}

	$.quad_multi4 = function( mat4, quad ){
		if ( ! mat4 )  return quad; // mat4=0 is identidy matrix , quad=no change
		var xy4 = [0,0 , 0,0 , 0,0 , 0,0];
		for ( var i=0; i < 8; i += 2 ){
			var x = quad[i+0];
			var y = quad[i+1];
			xy4[i+0] = mat4[0]*x + mat4[1]*y + mat4[2] + mat4[3];
			xy4[i+1] = mat4[4]*x + mat4[5]*y + mat4[6] + mat4[7];
		}
		return xy4;
	}

	// color * fogquad
	$.fog_multi4 = function( color, quad ){
		var c16 = [
			// r                g                   b                   a
			quad[ 0]*color[0] , quad[ 1]*color[1] , quad[ 2]*color[2] , quad[ 3]*color[3] , // c1
			quad[ 4]*color[0] , quad[ 5]*color[1] , quad[ 6]*color[2] , quad[ 7]*color[3] , // c2
			quad[ 8]*color[0] , quad[ 9]*color[1] , quad[10]*color[2] , quad[10]*color[3] , // c3
			quad[12]*color[0] , quad[13]*color[1] , quad[14]*color[2] , quad[15]*color[3] , // c4
		];
		return c16;
	}

	//////////////////////////////

} // function QuadMath

	function QuadExport(Q){
	var $ = this; // public
	var __ = {};  // private

	//////////////////////////////

	__.rect_compare = function( rect, xy ){
		if ( rect[0] > xy[0] )  rect[0] = xy[0]; // x1
		if ( rect[1] > xy[1] )  rect[1] = xy[1]; // y1
		if ( rect[2] < xy[2] )  rect[2] = xy[2]; // x2
		if ( rect[3] < xy[3] )  rect[3] = xy[3]; // y2
	}

	$.rect_attach = function( qdata, type, id ){
		if ( ! Q.func.is_valid_attach(qdata, type, id) )
			return 0;

		var max  = 1 << 24;
		var rect = [max,max,-max,-max];
		var is_null = true;

		var cur = qdata.quad[ type ][ id ];
		switch ( type ){
			case 'keyframe':
			case 'hitbox':
				if ( cur.__RECT )
					return cur.__RECT;

				var quad = '';
				if ( type === 'keyframe' )  quad = 'dstquad';
				if ( type === 'hitbox'   )  quad = 'hitquad';
				cur.layer.forEach(function(lv,lk){
					if ( ! lv || ! lv[quad] )
						return;
					var dst = lv[quad];
					for ( var i=0; i < 8; i += 2 ){
						if ( rect[0] > dst[i+0] )  rect[0] = dst[i+0]; // x1
						if ( rect[1] > dst[i+1] )  rect[1] = dst[i+1]; // y1
						if ( rect[2] < dst[i+0] )  rect[2] = dst[i+0]; // x2
						if ( rect[3] < dst[i+1] )  rect[3] = dst[i+1]; // y2
					} // for ( var i=0; i < 8; i += 2 )
				});
				cur.__RECT = rect;
				return rect;

			case 'slot':
				cur.forEach(function(sv,sk){
					var xy = $.rect_attach(qdata, sv.type, sv.id);
					if ( ! xy )
						return;
					is_null = false;
					__.rect_compare(rect, xy);
				});
				if ( is_null )
					return 0;
				return rect;

			case 'animation':
				if ( cur.__RECT )
					return cur.__RECT;

				var is_null = true;
				cur.timeline.forEach(function(tv,tk){
					if ( ! tv.attach )
						return;
					var xy = $.rect_attach(qdata, tv.attach.type, tv.attach.id);
					if ( ! xy )
						return;
					is_null = false;
					var xy2 = Q.math.rect_multi4(tv.matrix, xy);
					var t;
					if ( xy2[0] > xy2[2] ){ // if x1 > x2  swap()
						t = xy2[0];
						xy2[0] = xy[2];
						xy2[2] = t;
					}
					if ( xy2[1] > xy[3] ){ // if y1 > y2  swap()
						t = xy2[1];
						xy2[1] = xy2[3];
						xy2[3] = t;
					}
					__.rect_compare(rect, xy2);
				});
				if ( is_null )
					return 0;
				cur.__RECT = rect;
				return rect;

			case 'skeleton':
				if ( cur.__RECT )
					return cur.__RECT;

				cur.bone.forEach(function(bv,bk){
					if ( ! bv || ! bv.attach )
						return;
					var xy = $.rect_attach(qdata, bv.type, bv.id);
					if ( ! xy )
						return;
					is_null = false;
					__.rect_compare(rect, xy);
				});
				if ( is_null )
					return 0;
				cur.__RECT = rect;
				return rect;
		} // switch ( type )
		return 0;
	}

	$.is_loop_attach = function( qdata, type, id ){
		if ( ! Q.func.is_valid_attach(qdata, type, id) )
			return false;
		switch ( type ){
			case 'slot':
				var slot = qdata.quad.slot[id];
				for ( var i=0; i < slot.length; i++ ){
					var loop = $.is_loop_attach(qdata, slot[i].type, slot[i].id);
					if ( loop )
						return true;
				}
				return false;
			case 'animation':
				var loop = qdata.quad.animation[id].loop_id;
				if ( loop < 0 )
					return false;
				else
					return true;
			case 'skeleton':
				var bone = qdata.quad.skeleton[id].bone;
				for ( var i=0; i < bone.length; i++ ){
					if ( ! bone[i] || ! bone[i].attach )
						continue;
					var loop = $.is_loop_attach(qdata, bone[i].attach.type, bone[i].attach.id);
					if ( loop )
						return true;
				}
				return false;
		} // switch ( type )
		return false;
	}

	$.is_mix_attach = function( qdata, type, id ){
		if ( ! Q.func.is_valid_attach(qdata, type, id) )
			return false;
		switch ( type ){
			case 'slot':
				var slot = qdata.quad.slot[id];
				for ( var i=0; i < slot.length; i++ ){
					var mix = $.is_mix_attach(qdata, slot[i].type, slot[i].id);
					if ( mix )
						return true;
				}
				return false;
			case 'animation':
				var time = qdata.quad.animation[id].timeline;
				for ( var i=0; i < time.length; i++ ){
					var tv = time[i];
					var mix = 0;
					mix |= tv.matrix_mix;
					mix |= tv.color_mix;
					mix |= tv.keyframe_mix;
					mix |= tv.hitbox_mix;
					if ( mix )
						return true;
				}
				return false;
			case 'skeleton':
				var bone = qdata.quad.skeleton[id].bone;
				for ( var i=0; i < bone.length; i++ ){
					if ( ! bone[i] || ! bone[i].attach )
						continue;
					var mix = $.is_mix_attach(qdata, bone[i].attach.type, bone[i].attach.id);
					if ( mix )
						return true;
				}
				return false;
		} // switch ( type )
		return false;
	}

	$.time_attach = function( qdata, type, id ){
		if ( ! Q.func.is_valid_attach(qdata, type, id) )
			return 0;
		switch ( type ){
			case 'slot':
				var slot = qdata.quad.slot[id];
				var time = 0;
				for ( var i=0; i < slot.length; i++ ){
					var t = $.time_attach(qdata, slot[i].type, slot[i].id);
					if ( t > time )
						time = t;
				}
				return time;
			case 'animation':
				var anim = qdata.quad.animation[id].timeline;
				var time = 0;
				anim.forEach(function(av,ak){
					time += av.time;
				});
				return time;
			case 'skeleton':
				var bone = qdata.quad.skeleton[id].bone;
				var time = 0;
				bone.forEach(function(bv,bk){
					if ( ! bv || ! bv.attach )
						return;
					var t = $.time_attach(qdata, bv.attach.type, bv.attach.id);
					if ( t > time )
						time = t;
				});
				return time;
		} // switch ( type )
		return 0;
	}


	$.list_attach = function( qdata, type, id ){
		if ( ! Q.func.is_valid_attach(qdata, type, id) )
			return [];

		switch ( type ){
			case 'slot':
				var slot = qdata.quad.slot[id];
				var list = [];
				slot.forEach(function(sv,sk){
					list.push( sv.type +','+ sv.id );
				});
				Q.func.array_clean_dups(list);
				return list;
			case 'animation':
				var anim = qdata.quad.animation[id].timeline;
				var list = [];
				anim.forEach(function(tv,tk){
					if ( ! tv || ! tv.attach )
						return;
					list.push( tv.attach.type +','+ tv.attach.id );
				});
				Q.func.array_clean_dups(list);
				return list;
			case 'skeleton':
				var bone = qdata.quad.skeleton[id].bone;
				var list = [];
				bone.forEach(function(bv,bk){
					if ( ! bv || ! bv.attach )
						return;
					list.push( bv.attach.type +','+ bv.attach.id );
				});
				Q.func.array_clean_dups(list);
				return list;
		} // switch ( type )
		return [];
	}

	//////////////////////////////

	__.bak = {};
	__.backup = function( qdata, canvas, type, id, fps, zoom ){
		__.bak = {
			type  : qdata.attach.type ,
			id    : qdata.attach.id   ,
			fps   : qdata.anim_fps    ,
			zoom  : qdata.zoom        ,
			line  : qdata.is_lines    ,
			hit   : qdata.is_hits     ,
			canvw : canvas.width  ,
			canvh : canvas.height ,
			fname : qdata.name + '_' + type + '_' + id + '_' + fps,
		};
		qdata.attach.type = type;
		qdata.attach.id   = id;
		qdata.anim_fps    = fps;
		qdata.zoom        = zoom;
		qdata.is_lines    = false;
		qdata.is_hits     = false;
	}

	__.restore = function( qdata, canvas ){
		qdata.attach.type = __.bak.type;
		qdata.attach.id   = __.bak.id;
		qdata.anim_fps    = __.bak.fps;
		qdata.zoom        = __.bak.zoom;
		qdata.is_lines    = __.bak.line;
		qdata.is_hits     = __.bak.hit;
		canvas.width      = __.bak.canvw;
		canvas.height     = __.bak.canvh;
	}

	__.download = function( fname, dataurl ){
		if ( ! fname || ! dataurl )
			return;

		var a = document.createElement('a');
		a.href = dataurl;
		a.setAttribute('download', fname);
		a.setAttribute('target'  , '_blank');
		a.click();
	}

	//////////////////////////////

	__.export_sheet = function( qdata, canvas ){
		var line_spacing = 1.15;
		var sprsize = $.rect_attach(qdata, qdata.attach.type, qdata.attach.id);
		var sprwh = [
			(sprsize[2] - sprsize[0]) * line_spacing * qdata.zoom,
			(sprsize[3] - sprsize[1]) * line_spacing * qdata.zoom ,
		];
		var sprmid = [
			(sprsize[2] + sprsize[0]) * 0.5 * qdata.zoom ,
			(sprsize[3] + sprsize[1]) * 0.5 * qdata.zoom ,
		];

		var anim_time = $.time_attach(qdata, qdata.attach.type, qdata.attach.id);
		var texsize = Q.gl.max_texsize();

		var anim_remain = anim_time - qdata.anim_fps;
		var tilecol = 1;
		var tilerow = 1;
		var tile = [
			Math.floor(texsize / sprwh[0]),
			Math.floor(texsize / sprwh[1]),
		];
		if ( tile[0] >= anim_remain )
			tilecol = anim_remain;
		else {
			tilecol = tile[0];
			var y = Math.ceil(anim_remain / tile[0]);
			tilerow = ( y < tile[1] ) ? y : tile[1];
		}
		canvas.width  = tilecol * Math.floor(sprwh[0]);
		canvas.height = tilerow * Math.floor(sprwh[1]);

		// canvas from -halftex to +halftex
		// sprite 0,0 is at center
		var halfpos = [
			canvas.width * 0.5 , canvas.height * 0.5 ,
			sprwh[0]     * 0.5 , sprwh[1]      * 0.5 ,
		];

		var camera = Q.math.matrix4();
		var color  = [1,1,1,1];
		Q.func.qdata_clear(qdata);

		camera[0+0] = ( qdata.is_flipx ) ? -qdata.zoom : qdata.zoom;
		camera[4+1] = ( qdata.is_flipy ) ? -qdata.zoom : qdata.zoom;

		// from -1.0 to +1.0
		for ( var dy = -halfpos[1]; dy < halfpos[1]; dy += sprwh[1] ){
			if ( qdata.anim_fps >= anim_time )
				continue;

			// from -1.0 to +1.0
			for ( var dx = -halfpos[0]; dx < halfpos[0]; dx += sprwh[0] ){
				if ( qdata.anim_fps >= anim_time )
					continue;

				var m4 = Q.math.matrix4();
				m4[0+3] = dx + halfpos[2] - sprmid[0];
				m4[4+3] = dy + halfpos[3] - sprmid[1];
				m4 = Q.math.matrix_multi44(camera, m4);

				qdata.is_draw = false;
				Q.func.qdata_draw(qdata, m4, color);
				qdata.anim_fps++;
			} // for ( var dx = -canvpos[0]; dx < canvpos[0]; dx += sprwh[0] )
		} // for ( var dy = canvpos[1]; dy > -canvpos[1]; dy += sprwh[1] )

		return canvas.toDataURL('image/png');
	}

	__.export_zip = function( qdata, canvas, fmt ){
		var sprsize = $.rect_attach(qdata, qdata.attach.type, qdata.attach.id);
		var symm = Q.math.rect_symmetry(sprsize);

		var line_spacing = 1.15;
		canvas.width  = Math.ceil(symm[0] * 2 * line_spacing * qdata.zoom);
		canvas.height = Math.ceil(symm[1] * 2 * line_spacing * qdata.zoom);

		// same number of sprites as sheet
		var anim_time = $.time_attach(qdata, qdata.attach.type, qdata.attach.id);
		var texsize = Q.gl.max_texsize();
		var len  = Math.floor(texsize / canvas.width) * Math.floor(texsize / canvas.height);
		var list = {};

		var camera = Q.math.matrix4();
		var color  = [1,1,1,1];

		camera[0+0] = ( qdata.is_flipx ) ? -qdata.zoom : qdata.zoom;
		camera[4+1] = ( qdata.is_flipy ) ? -qdata.zoom : qdata.zoom;

		var i = 0;
		while ( i < len ){
			if ( qdata.anim_fps >= anim_time )
				break;
			Q.func.qdata_clear(qdata);
			Q.func.qdata_draw (qdata, camera, color);

			switch ( fmt ){
				case 'png':
					// %06d.png
					var pad = '00000000' + qdata.anim_fps + '.png';
					var fn  = pad.substring( pad.length - 10 );

					list[fn] = QUAD.binary.from_base64( canvas.toDataURL('image/png') );
					break;
				case 'rgba':
					// %06d.rgba
					var pad = '00000000' + qdata.anim_fps + '.rgba';
					var fn  = pad.substring( pad.length - 11 );

					list[fn] = Q.gl.read_RGBA();
					break;
			} // switch ( fmt )

			qdata.anim_fps++;
			i++;
		} // while ( i < len )

		var uint8 = Q.binary.zipwrite(list);
		return 'data:application/zip;base64,' + Q.binary.to_base64(uint8);
	}

	//////////////////////////////

	$.export = function( fmt, qdata, canvas, type, id, fps, zoom ){
		if ( zoom < 0.1 || zoom > 10.0 )
			return;
		var start = performance.now();
		__.backup(qdata, canvas, type, id, fps, zoom);

		switch ( fmt ){
			case 'png':
				var fname   = __.bak.fname + '.png';
				var dataurl = __.export_sheet(qdata, canvas);
				__.download(fname, dataurl);
				break;
			case 'zip':
				var fname   = __.bak.fname + '.png.zip';
				var dataurl = __.export_zip(qdata, canvas, 'png');
				__.download(fname, dataurl);
				break;
			case 'rgba':
				var fname   = __.bak.fname + '.rgba.zip';
				var dataurl = __.export_zip(qdata, canvas, 'rgba');
				__.download(fname, dataurl);
				break;
		} // switch ( fmt )

		__.restore(qdata, canvas);
		Q.func.log('QUAD export' , fmt , 'time' , performance.now()-start);

		// performance
		//   png    1193 ms   1,606,494 byte
		//   zip    4893 ms   3,332,087 byte
		//   rgba  62134 ms  59,437,722 byte
	}

	//////////////////////////////

} // function QuadExport

	function BinaryReader(){
	var $ = this; // public
	//var __ = {};  // private

	//////////////////////////////

	$.uint2txt = function( buf ){
		buf = new Uint8Array(buf);
		return $.getstr(buf, 0, buf.byteLength);
	}

	$.cat_uint8 = function( a, b ){
		var c = new Uint8Array( a.byteLength + b.byteLength );
		c.set(a, 0);
		c.set(b, a.byteLength);
		return c;
	}

	//////////////////////////////

	$.getint = function( buf, pos, len ){
		var int = 0;
		for ( var i=0; i < len; i++ )
			int |= (buf[pos+i] << (i*8));
		return int;
	}

	$.getstr = function( buf, pos, len ){
		var str = '';
		for ( var i=0; i < len; i++ )
			str += String.fromCharCode( buf[pos+i] );
		return str;
	}

	$.getsub = function( buf, pos, len ){
		var sub = new Uint8Array(len);
		for ( var i=0; i < len; i++ )
			sub[i] = buf[pos+i];
		return sub;
	}

	$.zipread = function( zipbuf ){
		zipbuf = new Uint8Array(zipbuf)
		var list = {};
		var pos  = 0;
		while (1)
		{
			var mgc = $.getint(zipbuf, pos, 4);
			if ( mgc !== 0x04034b50 )  // PK34
				break;

			var sz1 = $.getint(zipbuf, pos + 0x12, 4); // data size
			var sz2 = $.getint(zipbuf, pos + 0x1a, 2); // filename length
			var sz3 = $.getint(zipbuf, pos + 0x1c, 2); // extra length

			// uncompressed file/store only
			if ( zipbuf[pos + 8] === 0 ){
				var fn = $.getstr(zipbuf, pos + 0x1e            , sz2);
				var dt = $.getsub(zipbuf, pos + 0x1e + sz2 + sz3, sz1);
				list[fn] = dt;
			}

			pos += (0x1e + sz1 + sz2 + sz3);
		} // while (1)
		return list;
	}

	//////////////////////////////

	$.setint = function( buf, pos, len, int ){
		for ( var i=0; i < len; i++ ){
			var b = int >> (i*8);
			buf[pos+i] = b & 0xff;
		}
	}

	$.setstr = function( buf, pos, str ){
		for ( var i=0; i < str.length; i++ )
			buf[pos+i] = str.charCodeAt(i);
	}

	$.setsub = function( buf, pos, sub ){
		for ( var i=0; i < sub.byteLength; i++ )
			buf[pos+i] = sub[i];
	}

	$.zipwrite = function( list ){
		var key = Object.keys(list);
		var pk34len = 0;
		var pk12len = 0;
		var pk56len = 0x16;

		var fnlen, dtlen, dtcrc;
		for ( var i=0; i < key.length; i++ ){
			fnlen = key[i].length;
			dtlen = list[ key[i] ].byteLength;
			pk34len += (0x1e + fnlen + dtlen);
			pk12len += (0x2e + fnlen);
		} // for ( var i=0; i < key.length; i++ ){
		var zipbuf = new Uint8Array( pk34len + pk12len + pk56len );

		var pos34 = 0;
		var pos12 = pk34len;
		var pos56 = pk34len + pk12len;

		for ( var i=0; i < key.length; i++ ){
			fnlen = key[i].length;
			dtlen = list[ key[i] ].byteLength;
			dtcrc = $.crc32( list[ key[i] ] );

			$.setint(zipbuf , pos12 , 4 , 0x02014b50);  // PK12
			zipbuf[ pos12 + 0x04 ] = 10;  // ver 1.0
			zipbuf[ pos12 + 0x06 ] = 10;  // ver 1.0
			$.setsub(zipbuf , pos12 + 0x10 , dtcrc);
			$.setint(zipbuf , pos12 + 0x14 , 4 , dtlen);  // compressed
			$.setint(zipbuf , pos12 + 0x18 , 4 , dtlen);  // uncompressed
			$.setint(zipbuf , pos12 + 0x1c , 2 , fnlen);
			$.setint(zipbuf , pos12 + 0x2a , 4 , pos34);
				pos12 += 0x2e;
			$.setstr(zipbuf , pos12 , key[i]);
				pos12 += fnlen;

			$.setint(zipbuf , pos34 , 4 , 0x04034b50);  // PK34
			zipbuf[ pos34 + 0x04 ] = 10;  // ver 1.0
			$.setsub(zipbuf , pos34 + 0x0e , dtcrc);
			$.setint(zipbuf , pos34 + 0x12 , 4 , dtlen);  // compressed
			$.setint(zipbuf , pos34 + 0x16 , 4 , dtlen);  // uncompressed
			$.setint(zipbuf , pos34 + 0x1a , 2 , fnlen);
				pos34 += 0x1e;
			$.setstr(zipbuf , pos34 , key[i]);
				pos34 += fnlen;
			$.setsub(zipbuf , pos34 , list[ key[i] ]);
				pos34 += dtlen;
		} // for ( var i=0; i < key.length; i++ ){

		$.setint(zipbuf , pos56 , 4, 0x06054b50);  // PK56
		$.setint(zipbuf , pos56 + 0x08 , 2, key.length);  // disk entry
		$.setint(zipbuf , pos56 + 0x0a , 2, key.length);  // total entry
		$.setint(zipbuf , pos56 + 0x0c , 4, pk12len);  // PK12 length
		$.setint(zipbuf , pos56 + 0x10 , 4, pk34len);  // PK12 pos
		return zipbuf;
	}

	//////////////////////////////

	$.crc32 = function( uint8 ){
		uint8 = new Uint8Array(uint8);
		var crc = new Uint16Array([255,255,255,255]);

		// https://stackoverflow.com/questions/21001659/crc32-algorithm-implementation-in-c-without-a-look-up-table-and-with-a-public-li
		// https://web.archive.org/web/20190108202303/http://www.hackersdelight.org/hdcodetxt/crc.c.txt
		// https://web.archive.org/web/20190716204559/http://www.hackersdelight.org/permissions.htm
		function shift(){
			var carry = 0;
			[3,2,1,0].forEach(function(e){
				crc[e] |= (carry << 8);
				carry = crc[e] & 1;
				crc[e] >>= 1;
			});
			return carry;
		}
		function xor( int ){
			var b;
			[0,1,2,3].forEach(function(e){
				b = (int >> (e*8)) & 0xff;
				crc[e] ^= b;
			});
		}

		var len = uint8.byteLength;
		for ( var i=0; i < len; i++ ){
			xor( uint8[i] );
			for ( var j=0; j < 8; j++ ){
				var mask = shift();
				if ( mask )
					xor( 0xedb88320 );
			}
		}
		xor( 0xffffffff );
		return new Uint8Array(crc);
	}

	//////////////////////////////

	// base64
	// 4 * 6-bit ASCII == 3 * 8-bit BINARY
	// in 24-bit sets

	$.to_base64 = function( uint8 ){
		//uint8 = new Uint8Array(uint8);
		var token = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		var BIT6  = 0x3f;
		var len = uint8.byteLength;
		var pos = 0;

		var b, b1, b2, b3, b4;
		var b64 = '';
		while ( len >= 3 ){
			b = (uint8[pos+0] << 16) | (uint8[pos+1] << 8) | uint8[pos+2];
				pos += 3;
				len -= 3;

			b1 = (b >> 18) & BIT6;
			b2 = (b >> 12) & BIT6;
			b3 = (b >>  6) & BIT6;
			b4 = (b >>  0) & BIT6;
			b64 += token[b1] + token[b2] + token[b3] + token[b4];
		} // while ( len >= 3 ){

		if ( len === 2 ){
			b = (uint8[pos+0] << 8) | uint8[pos+1];
				b <<= 2

			b1 = (b >> 12) & BIT6;
			b2 = (b >>  6) & BIT6;
			b3 = (b >>  0) & BIT6;
			b64 += token[b1] + token[b2] + token[b3] + '=';
		}
		if ( len === 1 ){
			b = uint8[pos+0];
				b <<= 4;

			b1 = (b >>  6) & BIT6;
			b2 = (b >>  0) & BIT6;
			b64 += token[b1] + token[b2] + '==';
		}
		return b64;
	}

	$.from_base64 = function( b64 ){
		// data URL handling
		var st  = 0;
		var pos = b64.indexOf('base64,');
		if ( pos !== -1 )
			st = pos + 7;

		// must be length % 4 === 0
		var len = b64.length - st;
		if ( len < 1 || (len & 3) !== 0 )
			return '';

		// Uint8Array.reserve()
		var declen = (len >> 2) * 3;
		if ( b64[ b64.length - 1 ] === '=' ){
			declen--;
			if ( b64[ b64.length - 2 ] === '=' )
				declen--;
		}
		var uint8 = new Uint8Array(declen);

		var token = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		var BIT8  = 0xff;

		var b, b1, b2, b3, b4;
		var dpos = 0;
		for ( var pos = st; pos < b64.length; pos += 4 ){
			b1 = token.indexOf( b64[pos+0] );
			b2 = token.indexOf( b64[pos+1] );

			if ( b64[pos+2] === '=' ){
				b = (b1 << 6) | b2;
					b >>= 4;
				uint8[dpos+0] = (b >> 0) & BIT8;
					dpos += 1;
				continue;
			}

			b3 = token.indexOf( b64[pos+2] );
			if ( b64[pos+3] === '=' ){
				b = (b1 << 12) | (b2 << 6) | b3;
					b >>= 2;
				uint8[dpos+0] = (b >> 8) & BIT8;
				uint8[dpos+1] = (b >> 0) & BIT8;
					dpos += 2;
				continue;
			}

			b4 = token.indexOf( b64[pos+3] );
			b = (b1 << 18) | (b2 << 12) | (b3 << 6) | b4;

			uint8[dpos+0] = (b >> 16) & BIT8;
			uint8[dpos+1] = (b >>  8) & BIT8;
			uint8[dpos+2] = (b >>  0) & BIT8;
				dpos += 3;
		} // for ( var pos=0; pos < b64.length; pos += 4 ){
		return uint8;
	}

	//////////////////////////////

} // function BinaryReader


	$.version = 'ver 2024-3-11 (beta)';
	$.gl   = new QuadGL  ($);
	$.func = new QuadFunc($);
	$.math = new QuadMath($);
	$.export = new QuadExport($);
	$.binary = new BinaryReader();

})(QUAD);

function QuadData(qlist){
	var $ = this;
	$.list = qlist;

	// uploaded files
	$.name = '';
	$.quad  = {};
	$.image = []; // { pos:rect , name:string }
	$.vram  = QUAD.gl.create_pixel(255,-1,-1); // white texture

	// activated data
	$.is_wait  = true;
	$.is_draw  = false;
	$.is_hits  = true;
	$.is_lines = true;
	$.is_flipx = false;
	$.is_flipy = false;
	$.zoom   = 1;
	$.matrix = [1,0,0,0 , 0,1,0,0 , 0,0,1,0 , 0,0,0,1];
	$.color  = [1,1,1,1];

	$.attach = {
		type : '',
		id   : 0
	};
	$.anim_fps = 0;
	$.line_index = 0;
	$.prev = ['',-1,-1,true,true,false,false,1];
}
</script>
</head><body>

<div id='debugger'>
	<input type='file' id='input_file' multiple class='hidden'>
	<div id='debugger_top_nav'>
		<p id='debugger_top_row_1'>
			<button id='btn_view'>view</button>
			<button id='btn_upload' data-id='0'>upload</button>
		</p>
	</div>

	<button>dummy</button>
	<h1 id='quad_version'></h1>
	<h2>Files</h2>
	<ol id='debugger_files'></ol>
	<div id='quad_data'></div>
	<h3>Logs</h3>
	<textarea id='logger' disabled></textarea>
	<p>
		<a href='https://rufaswan.github.io/Web2D_Games/quad_player_mobile/player-mobile.tpl.html' target='_blank'>Latest version</a> -
		<a href='https://rufaswan.github.io/Web2D_Games/quad_player_mobile/spec.html' target='_blank'>QUAD File Spec</a> -
		<a href='https://github.com/rufaswan/Web2D_Games' target='_blank'>Github</a>
	</p>

	<div id='export_div' data-type='' data-id=''>
		<p id='export_name'></p>
		<p>
			START = <span id='export_start'>0</span>
			<input id='export_range' type='range' min='0' max='0' step='1' value='0'>
		</p>
		<p>
			ZOOM = <span id='export_zoom'>1.0</span>
			<input id='export_times' type='range' min='0.1' max='10.0' step='0.1' value='1.0'>
		</p>
		<p>
			<button onclick='button_export_type(this);'>png</button>
			<button onclick='button_export_type(this);'>zip</button>
			<button onclick='button_export_type(this);'>rgba</button>
		</p>
	</div>
</div>

<div id='viewer'>
	<img id="bg_q3_png" alt="bg_q3_png" title="bg_q3_png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQAQMAAAC032DuAAAABlBMVEVAQEDAwMCo6TBpAAAAGklEQVQoz2NgAIEGBjgYZY4yB5r5Hw6Gnd8AoYMxdx81TTIAAAAASUVORK5CYII=">
	<canvas id='canvas'>Canvas not supported</canvas>
	<div id='viewer_top_nav'>
		<p id='viewer_top_row_1'>
			<button id='btn_debug'>debug</button>
			<button id='btn_hits' class='btn_on'>hit</button>
			<button id='btn_flipx' class='btn_off'>X</button>
			<button id='btn_lines'>line</button>
		</p>
	</div>
	<div id='viewer_bottom_nav'>
		<p id='viewer_bottom_row_1'>
			<button id='btn_prev'>&lt;&lt;</button>

			<button id='btn_autonext'>auto</button>
			<button id='btn_cur'>0</button>

			<button id='btn_next'>&gt;&gt;</button>
		</p>
	</div>
</div>

<script>
var HTML = get_html_id();
var QuadList = [];
var SELECTED = '';

(function(){
	if ( ! QUAD.gl.init(HTML.canvas) )
		return;

	HTML.quad_version.innerHTML = 'Quad Player ' + QUAD.version;

	// BETWEEN DEBUGGER-VIEWER
	HTML.btn_view.addEventListener('click', function(){
		display_viewer(HTML, true);
	});
	HTML.btn_debug.addEventListener('click', function(){
		display_viewer(HTML, false);
		HTML.logger.innerHTML = QUAD.func.console();
	});

	var UPLOAD_ID = -1;
	HTML.btn_upload.addEventListener('click', function(){
		UPLOAD_ID = this.getAttribute('data-id');
		HTML.input_file.click();
		HTML.logger.innerHTML = QUAD.func.console();
	});
	HTML.input_file.addEventListener('change', function(){
		QUAD.func.log('QuadList[]', UPLOAD_ID);
		if ( QUAD.func.is_undef( QuadList[ UPLOAD_ID ] ) )
			QuadList[ UPLOAD_ID ] = new QuadData(QuadList);
		var qdata = QuadList[ UPLOAD_ID ];

		var promises = [];
		for ( var up of this.files )
			promises.push( QUAD.func.upload_promise(up, qdata) );

		Promise.all(promises).then(function(resolve){
			qdata_filetable(qdata, HTML.debugger_files);
			if ( qdata.name ){
				HTML.quad_data.innerHTML = '';
				document.title = qdata.name + ' [Quad Player ' + QUAD.version + ']';

				var buffer = qdata_tagtable(qdata.quad.tag);
				HTML.quad_data.innerHTML += buffer;

				var quad_main = quad_mainlist(qdata.quad);
				if ( quad_main === -1 )
					return;

				var buffer = '<h2>' + quad_main + '</h2>';
				buffer += '<ul>';
				qdata.quad[quad_main].forEach(function(v,k){
					if ( ! v )
						return;
					buffer += qdata_listing(qdata, quad_main, k);

				});
				buffer += '</ul>';
				HTML.quad_data.innerHTML += buffer;
			} // if ( qdata.name )
			HTML.logger.innerHTML = QUAD.func.console();
		});
	});
	HTML.export_range.addEventListener('change', function(){
		HTML.export_start.innerHTML = this.value;
	});
	HTML.export_times.addEventListener('change', function(){
		HTML.export_zoom.innerHTML = this.value;
	});

	// VIEWER
	var IS_VIEWER_NAV = true;
	var IS_AUTOZOOM   = true;
	HTML.canvas.addEventListener('click', function(){
		if ( IS_VIEWER_NAV ) {
			HTML.viewer_top_nav.style.display    = 'none';
			HTML.viewer_bottom_nav.style.display = 'none';
		} else {
			HTML.viewer_top_nav.style.display    = 'block';
			HTML.viewer_bottom_nav.style.display = 'block';
		}
		IS_VIEWER_NAV = ! IS_VIEWER_NAV;
	});
	HTML.btn_lines.addEventListener('click', function(){
		if ( ! QuadList[0] )
			return;
		QuadList[0].is_lines = ! QuadList[0].is_lines;
		HTML.btn_lines.innerHTML = ( QuadList[0].is_lines ) ? 'line' : 'tex';
	});
	HTML.btn_hits.addEventListener('click', function(){
		if ( ! QuadList[0] )
			return;
		if ( HTML.btn_hits.classList.contains('btn_on') ){
			btn_toggle(HTML.btn_hits, -1);
			QuadList[0].is_hits = false;
		} else {
			btn_toggle(HTML.btn_hits, 1);
			QuadList[0].is_hits = true;
		}
	});
	HTML.btn_flipx.addEventListener('click', function(){
		if ( ! QuadList[0] )
			return;
		if ( HTML.btn_flipx.classList.contains('btn_on') ){
			btn_toggle(HTML.btn_flipx, -1);
			QuadList[0].is_flipx = false;
		} else {
			btn_toggle(HTML.btn_flipx, 1);
			QuadList[0].is_flipx = true;
		}
	});

	var IS_BTN_CLICK = 0;
	var IS_AUTONEXT  = false;
	HTML.btn_prev.addEventListener('click', function(){
		if ( IS_AUTONEXT ){
			btn_toggle(HTML.btn_next, -1);
			if ( HTML.btn_prev.classList.contains('btn_on') ){
				btn_toggle(HTML.btn_prev, -1);
				IS_BTN_CLICK = 0;
			} else {
				btn_toggle(HTML.btn_prev, 1);
				IS_BTN_CLICK = -1;
			}
		} else
			IS_BTN_CLICK = -1;
	});
	HTML.btn_next.addEventListener('click', function(){
		if ( IS_AUTONEXT ){
			btn_toggle(HTML.btn_prev, -1);
			if ( HTML.btn_next.classList.contains('btn_on') ){
				btn_toggle(HTML.btn_next, -1);
				IS_BTN_CLICK = 0;
			} else {
				btn_toggle(HTML.btn_next, 1);
				IS_BTN_CLICK = 1;
			}
		} else
			IS_BTN_CLICK = 1;
	});
	HTML.btn_autonext.addEventListener('click', function(){
		if ( IS_AUTONEXT ){
			btn_toggle(HTML.btn_prev, 0);
			btn_toggle(HTML.btn_next, 0);
			IS_AUTONEXT = false;
		} else {
			btn_toggle(HTML.btn_prev, -1);
			btn_toggle(HTML.btn_next, -1);
			IS_AUTONEXT = true;
		}
	});

	var FPS_DRAW = 0;
	var CAMERA = QUAD.math.matrix4();
	var COLOR  = [1,1,1,1];
	function render(){
		requestAnimationFrame(render);
		if ( HTML.viewer.style.display !== 'block' )
			return;
		if ( ! QuadList[0] || ! QuadList[0].name )
			return;
		var qdata = QuadList[0];

		// auto forward by 60/8 fps = 7.5 fps
		if ( (FPS_DRAW & 7) === 0 ){
			btn_prev_next(qdata, IS_BTN_CLICK);
			if ( ! IS_AUTONEXT )
				IS_BTN_CLICK = 0;
		}

		// update/redraw only when changed
		if ( QUAD.gl.is_canvas_resized() || QUAD.func.is_changed(qdata) ){
			CAMERA = QUAD.func.viewer_camera(qdata, IS_AUTOZOOM);
			HTML.btn_cur.innerHTML = qdata.attach.id + '/' + qdata.anim_fps;
			HTML.logger.innerHTML  = QUAD.func.console();

			QUAD.func.qdata_clear(qdata);
			QUAD.func.qdata_draw(qdata, CAMERA, COLOR);
			if ( ! qdata.is_draw ){
				HTML.btn_cur.innerHTML = 'END';
			}
		}

		FPS_DRAW = (FPS_DRAW + 1) & 0xff;
	}
	render();
})();
</script>

</body></html>
